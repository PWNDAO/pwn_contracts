{
    "language": "Solidity",
    "settings": {
        "evmVersion": "istanbul",
        "libraries": {},
        "metadata": {
            "bytecodeHash": "ipfs"
        },
        "optimizer": {
            "enabled": true,
            "runs": 1000000
        },
        "remappings": []
    },
    "sources": {
        "@chainlink/contracts/src/v0.7/dev/ConfirmedOwner.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./ConfirmedOwnerWithProposal.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n\n  constructor(\n    address newOwner\n  )\n    ConfirmedOwnerWithProposal(\n      newOwner,\n      address(0)\n    )\n  {\n  }\n\n}\n"
        },
        "@chainlink/contracts/src/v0.7/dev/ConfirmedOwnerWithProposal.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../interfaces/OwnableInterface.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\n\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(\n    address indexed from,\n    address indexed to\n  );\n  event OwnershipTransferred(\n    address indexed from,\n    address indexed to\n  );\n\n  constructor(\n    address owner,\n    address pendingOwner\n  ) {\n    require(owner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = owner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /**\n   * @notice Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(\n    address to\n  )\n    public\n    override\n    onlyOwner()\n  {\n    _transferOwnership(to);\n  }\n\n  /**\n   * @notice Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership()\n    external\n    override\n  {\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @notice Get the current owner\n   */\n  function owner()\n    public\n    view\n    override\n    returns (\n      address\n    )\n  {\n    return s_owner;\n  }\n\n  /**\n   * @notice validate, transfer ownership, and emit relevant events\n   */\n  function _transferOwnership(\n    address to\n  )\n    private\n  {\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /**\n   * @notice validate access\n   */\n  function _validateOwnership()\n    internal\n    view\n  {\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /**\n   * @notice Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n\n}\n"
        },
        "@chainlink/contracts/src/v0.7/interfaces/AggregatorInterface.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface AggregatorInterface {\n  function latestAnswer()\n    external\n    view\n    returns (\n      int256\n    );\n  \n  function latestTimestamp()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  function latestRound()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  function getAnswer(\n    uint256 roundId\n  )\n    external\n    view\n    returns (\n      int256\n    );\n\n  function getTimestamp(\n    uint256 roundId\n  )\n    external\n    view\n    returns (\n      uint256\n    );\n\n  event AnswerUpdated(\n    int256 indexed current,\n    uint256 indexed roundId,\n    uint256 updatedAt\n  );\n\n  event NewRound(\n    uint256 indexed roundId,\n    address indexed startedBy,\n    uint256 startedAt\n  );\n}\n"
        },
        "@chainlink/contracts/src/v0.7/interfaces/AggregatorV2V3Interface.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\n{\n}\n"
        },
        "@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
        },
        "@chainlink/contracts/src/v0.7/interfaces/OwnableInterface.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface OwnableInterface {\n  function owner()\n    external\n    returns (\n      address\n    );\n\n  function transferOwnership(\n    address recipient\n  )\n    external;\n\n  function acceptOwnership()\n    external;\n}\n"
        },
        "contracts/FeedRegistry.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2; // solhint-disable compiler-version\n\nimport \"@chainlink/contracts/src/v0.7/interfaces/AggregatorV2V3Interface.sol\";\nimport \"./access/AccessControlled.sol\";\nimport \"./interfaces/FeedRegistryInterface.sol\";\nimport \"./interfaces/TypeAndVersionInterface.sol\";\n\n/**\n  * @notice An on-chain registry of assets to aggregators.\n  * @notice This contract provides a consistent address for consumers but delegates where it reads from to the owner, who is\n  * trusted to update it. This registry contract works for multiple feeds, not just a single aggregator.\n  * @notice Only access enabled addresses are allowed to access getters for answers and round data\n  */\ncontract FeedRegistry is FeedRegistryInterface, TypeAndVersionInterface, AccessControlled {\n  uint256 constant private PHASE_OFFSET = 64;\n  uint256 constant private PHASE_SIZE = 16;\n  uint256 constant private MAX_ID = 2**(PHASE_OFFSET+PHASE_SIZE) - 1;\n\n  mapping(address => bool) private s_isAggregatorEnabled;\n  mapping(address => mapping(address => AggregatorV2V3Interface)) private s_proposedAggregators;\n  mapping(address => mapping(address => uint16)) private s_currentPhaseId;\n  mapping(address => mapping(address => mapping(uint16 => AggregatorV2V3Interface))) private s_phaseAggregators;\n  mapping(address => mapping(address => mapping(uint16 => Phase))) private s_phases;\n\n  /*\n   * @notice Versioning\n   */\n  function typeAndVersion()\n    external\n    override\n    pure\n    virtual\n    returns (\n      string memory\n    )\n  {\n    return \"FeedRegistry 1.0.0\";\n  }\n\n  /**\n   * @notice represents the number of decimals the aggregator responses represent.\n   */\n  function decimals(\n    address base,\n    address quote\n  )\n    external\n    view\n    override\n    returns (\n      uint8\n    )\n  {\n    AggregatorV2V3Interface aggregator = _getFeed(base, quote);\n    require(address(aggregator) != address(0), \"Feed not found\");\n    return aggregator.decimals();\n  }\n\n  /**\n   * @notice returns the description of the aggregator the proxy points to.\n   */\n  function description(\n    address base,\n    address quote\n  )\n    external\n    view\n    override\n    returns (\n      string memory\n    )\n  {\n    AggregatorV2V3Interface aggregator = _getFeed(base, quote);\n    require(address(aggregator) != address(0), \"Feed not found\");\n    return aggregator.description();\n  }\n\n  /**\n   * @notice the version number representing the type of aggregator the proxy\n   * points to.\n   */\n  function version(\n    address base,\n    address quote\n  )\n    external\n    view\n    override\n    returns (\n      uint256\n    )\n  {\n    AggregatorV2V3Interface aggregator = _getFeed(base, quote);\n    require(address(aggregator) != address(0), \"Feed not found\");\n    return aggregator.version();\n  }\n\n  /**\n   * @notice get data about the latest round. Consumers are encouraged to check\n   * that they're receiving fresh data by inspecting the updatedAt and\n   * answeredInRound return values.\n   * Note that different underlying implementations of AggregatorV3Interface\n   * have slightly different semantics for some of the return values. Consumers\n   * should determine what implementations they expect to receive\n   * data from and validate that they can properly handle return data from all\n   * of them.\n   * @param base base asset address\n   * @param quote quote asset address\n   * @return roundId is the round ID from the aggregator for which the data was\n   * retrieved combined with a phase to ensure that round IDs get larger as\n   * time moves forward.\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @dev Note that answer and updatedAt may change between queries.\n   */\n  function latestRoundData(\n    address base,\n    address quote\n  )\n    external\n    view\n    override\n    checkPairAccess()\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    uint16 currentPhaseId = s_currentPhaseId[base][quote];\n    AggregatorV2V3Interface aggregator = _getFeed(base, quote);\n    require(address(aggregator) != address(0), \"Feed not found\");\n    (\n      roundId,\n      answer,\n      startedAt,\n      updatedAt,\n      answeredInRound\n    ) = aggregator.latestRoundData();\n    return _addPhaseIds(roundId, answer, startedAt, updatedAt, answeredInRound, currentPhaseId);\n  }\n\n  /**\n   * @notice get data about a round. Consumers are encouraged to check\n   * that they're receiving fresh data by inspecting the updatedAt and\n   * answeredInRound return values.\n   * Note that different underlying implementations of AggregatorV3Interface\n   * have slightly different semantics for some of the return values. Consumers\n   * should determine what implementations they expect to receive\n   * data from and validate that they can properly handle return data from all\n   * of them.\n   * @param base base asset address\n   * @param quote quote asset address\n   * @param _roundId the proxy round id number to retrieve the round data for\n   * @return roundId is the round ID from the aggregator for which the data was\n   * retrieved combined with a phase to ensure that round IDs get larger as\n   * time moves forward.\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @dev Note that answer and updatedAt may change between queries.\n   */\n  function getRoundData(\n    address base,\n    address quote,\n    uint80 _roundId\n  )\n    external\n    view\n    override\n    checkPairAccess()\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    (uint16 phaseId, uint64 aggregatorRoundId) = _parseIds(_roundId);\n    AggregatorV2V3Interface aggregator = _getPhaseFeed(base, quote, phaseId);\n    require(address(aggregator) != address(0), \"Feed not found\");\n    (\n      roundId,\n      answer,\n      startedAt,\n      updatedAt,\n      answeredInRound\n    ) = aggregator.getRoundData(aggregatorRoundId);\n    return _addPhaseIds(roundId, answer, startedAt, updatedAt, answeredInRound, phaseId);\n  }\n\n\n  /**\n   * @notice Reads the current answer for an base / quote pair's aggregator.\n   * @param base base asset address\n   * @param quote quote asset address\n   * @notice We advise to use latestRoundData() instead because it returns more in-depth information.\n   * @dev This does not error if no answer has been reached, it will simply return 0. Either wait to point to\n   * an already answered Aggregator or use the recommended latestRoundData\n   * instead which includes better verification information.\n   */\n  function latestAnswer(\n    address base,\n    address quote\n  )\n    external\n    view\n    override\n    checkPairAccess()\n    returns (\n      int256 answer\n    )\n  {\n    AggregatorV2V3Interface aggregator = _getFeed(base, quote);\n    require(address(aggregator) != address(0), \"Feed not found\");\n    return aggregator.latestAnswer();\n  }\n\n  /**\n   * @notice get the latest completed timestamp where the answer was updated.\n   * @param base base asset address\n   * @param quote quote asset address\n   *\n   * @notice We advise to use latestRoundData() instead because it returns more in-depth information.\n   * @dev This does not error if no answer has been reached, it will simply return 0. Either wait to point to\n   * an already answered Aggregator or use the recommended latestRoundData\n   * instead which includes better verification information.\n   */\n  function latestTimestamp(\n    address base,\n    address quote\n  )\n    external\n    view\n    override\n    checkPairAccess()\n    returns (\n      uint256 timestamp\n    )\n  {\n    AggregatorV2V3Interface aggregator = _getFeed(base, quote);\n    require(address(aggregator) != address(0), \"Feed not found\");\n    return aggregator.latestTimestamp();\n  }\n\n  /**\n   * @notice get the latest completed round where the answer was updated\n   * @param base base asset address\n   * @param quote quote asset address\n   * @dev overridden function to add the checkPairAccess() modifier\n   *\n   * @notice We advise to use latestRoundData() instead because it returns more in-depth information.\n   * @dev Use latestRoundData instead. This does not error if no\n   * answer has been reached, it will simply return 0. Either wait to point to\n   * an already answered Aggregator or use the recommended latestRoundData\n   * instead which includes better verification information.\n   */\n  function latestRound(\n    address base,\n    address quote\n  )\n    external\n    view\n    override\n    checkPairAccess()\n    returns (\n      uint256 roundId\n    )\n  {\n    uint16 currentPhaseId = s_currentPhaseId[base][quote];\n    AggregatorV2V3Interface aggregator = _getFeed(base, quote);\n    require(address(aggregator) != address(0), \"Feed not found\");\n    return _addPhase(currentPhaseId, uint64(aggregator.latestRound()));\n  }\n\n  /**\n   * @notice get past rounds answers\n   * @param base base asset address\n   * @param quote quote asset address\n   * @param roundId the proxy round id number to retrieve the answer for\n   * @dev overridden function to add the checkPairAccess() modifier\n   *\n   * @notice We advise to use getRoundData() instead because it returns more in-depth information.\n   * @dev This does not error if no answer has been reached, it will simply return 0. Either wait to point to\n   * an already answered Aggregator or use the recommended getRoundData\n   * instead which includes better verification information.\n   */\n  function getAnswer(\n    address base,\n    address quote,\n    uint256 roundId\n  )\n    external\n    view\n    override\n    checkPairAccess()\n    returns (\n      int256 answer\n    )\n  {\n    if (roundId > MAX_ID) return 0;\n    (uint16 phaseId, uint64 aggregatorRoundId) = _parseIds(roundId);\n    AggregatorV2V3Interface aggregator = _getPhaseFeed(base, quote, phaseId);\n    if (address(aggregator) == address(0)) return 0;\n    return aggregator.getAnswer(aggregatorRoundId);\n  }\n\n  /**\n   * @notice get block timestamp when an answer was last updated\n   * @param base base asset address\n   * @param quote quote asset address\n   * @param roundId the proxy round id number to retrieve the updated timestamp for\n   * @dev overridden function to add the checkPairAccess() modifier\n   *\n   * @notice We advise to use getRoundData() instead because it returns more in-depth information.\n   * @dev This does not error if no answer has been reached, it will simply return 0. Either wait to point to\n   * an already answered Aggregator or use the recommended getRoundData\n   * instead which includes better verification information.\n   */\n  function getTimestamp(\n    address base,\n    address quote,\n    uint256 roundId\n  )\n    external\n    view\n    override\n    checkPairAccess()\n    returns (\n      uint256 timestamp\n    )\n  {\n    if (roundId > MAX_ID) return 0;\n    (uint16 phaseId, uint64 aggregatorRoundId) = _parseIds(roundId);\n    AggregatorV2V3Interface aggregator = _getPhaseFeed(base, quote, phaseId);\n    if (address(aggregator) == address(0)) return 0;\n    return aggregator.getTimestamp(aggregatorRoundId);\n  }\n\n\n  /**\n   * @notice Retrieve the aggregator of an base / quote pair in the current phase\n   * @param base base asset address\n   * @param quote quote asset address\n   * @return aggregator\n   */\n  function getFeed(\n    address base,\n    address quote\n  )\n    external\n    view\n    override\n    returns (\n      AggregatorV2V3Interface aggregator\n    )\n  {\n    aggregator = _getFeed(base, quote);\n    require(address(aggregator) != address(0), \"Feed not found\");\n  }\n\n  /**\n   * @notice retrieve the aggregator of an base / quote pair at a specific phase\n   * @param base base asset address\n   * @param quote quote asset address\n   * @param phaseId phase ID\n   * @return aggregator\n   */\n  function getPhaseFeed(\n    address base,\n    address quote,\n    uint16 phaseId\n  )\n    external\n    view\n    override\n    returns (\n      AggregatorV2V3Interface aggregator\n    )\n  {\n    aggregator = _getPhaseFeed(base, quote, phaseId);\n    require(address(aggregator) != address(0), \"Feed not found for phase\");\n  }\n\n  /**\n   * @notice returns true if a aggregator is enabled for any pair\n   * @param aggregator aggregator address\n   */\n  function isFeedEnabled(\n    address aggregator\n  )\n    external\n    view\n    override\n    returns (\n      bool\n    )\n  {\n    return s_isAggregatorEnabled[aggregator];\n  }\n\n  /**\n   * @notice returns a phase by id. A Phase contains the starting and ending aggregator round ids.\n   * endingAggregatorRoundId will be 0 if the phase is the current phase\n   * @dev reverts if the phase does not exist\n   * @param base base asset address\n   * @param quote quote asset address\n   * @param phaseId phase id\n   * @return phase\n   */\n  function getPhase(\n    address base,\n    address quote,\n    uint16 phaseId\n  )\n    external\n    view\n    override\n    returns (\n      Phase memory phase\n    )\n  {\n    phase = _getPhase(base, quote, phaseId);\n    require(_phaseExists(phase), \"Phase does not exist\");\n  }\n\n  /**\n   * @notice retrieve the aggregator of an base / quote pair at a specific round id\n   * @param base base asset address\n   * @param quote quote asset address\n   * @param roundId the proxy round id\n   */\n  function getRoundFeed(\n    address base,\n    address quote,\n    uint80 roundId\n  )\n    external\n    view\n    override\n    returns (\n      AggregatorV2V3Interface aggregator\n    )\n  {\n    uint16 phaseId = _getPhaseIdByRoundId(base, quote, roundId);\n    aggregator = _getPhaseFeed(base, quote, phaseId);\n    require(address(aggregator) != address(0), \"Feed not found for round\");\n  }\n\n  /**\n   * @notice returns the range of proxy round ids of a phase\n   * @param base base asset address\n   * @param quote quote asset address\n   * @param phaseId phase id\n   * @return startingRoundId\n   * @return endingRoundId\n   */\n  function getPhaseRange(\n    address base,\n    address quote,\n    uint16 phaseId\n  )\n    external\n    view\n    override\n    returns (\n      uint80 startingRoundId,\n      uint80 endingRoundId\n    )\n  {\n    Phase memory phase = _getPhase(base, quote, phaseId);\n    require(_phaseExists(phase), \"Phase does not exist\");\n\n    uint16 currentPhaseId = s_currentPhaseId[base][quote];\n    if (phaseId == currentPhaseId) return _getLatestRoundRange(base, quote, currentPhaseId);\n    return _getPhaseRange(base, quote, phaseId);\n  }\n\n  /**\n   * @notice return the previous round id of a given round\n   * @param base base asset address\n   * @param quote quote asset address\n   * @param roundId the round id number to retrieve the updated timestamp for\n   * @dev Note that this is not the aggregator round id, but the proxy round id\n   * To get full ranges of round ids of different phases, use getPhaseRange()\n   * @return previousRoundId\n   */\n  function getPreviousRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external\n    view\n    override\n    returns (\n      uint80 previousRoundId\n    )\n  {\n    uint16 phaseId = _getPhaseIdByRoundId(base, quote, roundId);\n    return _getPreviousRoundId(base, quote, phaseId, roundId);\n  }\n\n  /**\n   * @notice return the next round id of a given round\n   * @param base base asset address\n   * @param quote quote asset address\n   * @param roundId the round id number to retrieve the updated timestamp for\n   * @dev Note that this is not the aggregator round id, but the proxy round id\n   * To get full ranges of round ids of different phases, use getPhaseRange()\n   * @return nextRoundId\n   */\n  function getNextRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external\n    view\n    override\n    returns (\n      uint80 nextRoundId\n    )\n  {\n    uint16 phaseId = _getPhaseIdByRoundId(base, quote, roundId);\n    return _getNextRoundId(base, quote, phaseId, roundId);\n  }\n\n  /**\n   * @notice Allows the owner to propose a new address for the aggregator\n   * @param base base asset address\n   * @param quote quote asset address\n   * @param aggregator The new aggregator contract address\n   */\n  function proposeFeed(\n    address base,\n    address quote,\n    address aggregator\n  )\n    external\n    override\n    onlyOwner()\n  {\n    AggregatorV2V3Interface currentPhaseAggregator = _getFeed(base, quote);\n    require(aggregator != address(currentPhaseAggregator), \"Cannot propose current aggregator\");\n    address proposedAggregator = address(_getProposedFeed(base, quote));\n    if (proposedAggregator != aggregator) {\n      s_proposedAggregators[base][quote] = AggregatorV2V3Interface(aggregator);\n      emit FeedProposed(base, quote, aggregator, address(currentPhaseAggregator), msg.sender);\n    }\n  }\n\n  /**\n   * @notice Allows the owner to confirm and change the address\n   * to the proposed aggregator\n   * @dev Reverts if the given address doesn't match what was previously\n   * proposed\n   * @param base base asset address\n   * @param quote quote asset address\n   * @param aggregator The new aggregator contract address\n   */\n  function confirmFeed(\n    address base,\n    address quote,\n    address aggregator\n  )\n    external\n    override\n    onlyOwner()\n  {\n    (uint16 nextPhaseId, address previousAggregator) = _setFeed(base, quote, aggregator);\n    delete s_proposedAggregators[base][quote];\n    s_isAggregatorEnabled[aggregator] = true;\n    s_isAggregatorEnabled[previousAggregator] = false;\n    emit FeedConfirmed(base, quote, aggregator, previousAggregator, nextPhaseId, msg.sender);\n  }\n\n  /**\n   * @notice Returns the proposed aggregator for an base / quote pair\n   * returns a zero address if there is no proposed aggregator for the pair\n   * @param base base asset address\n   * @param quote quote asset address\n   * @return proposedAggregator\n  */\n  function getProposedFeed(\n    address base,\n    address quote\n  )\n    external\n    view\n    override\n    returns (\n      AggregatorV2V3Interface proposedAggregator\n    )\n  {\n    return _getProposedFeed(base, quote);\n  }\n\n  /**\n   * @notice Used if an aggregator contract has been proposed.\n   * @param base base asset address\n   * @param quote quote asset address\n   * @param roundId the round ID to retrieve the round data for\n   * @return id is the round ID for which data was retrieved\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed.\n  */\n  function proposedGetRoundData(\n    address base,\n    address quote,\n    uint80 roundId\n  )\n    external\n    view\n    virtual\n    override\n    hasProposal(base, quote)\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return s_proposedAggregators[base][quote].getRoundData(roundId);\n  }\n\n  /**\n   * @notice Used if an aggregator contract has been proposed.\n   * @param base base asset address\n   * @param quote quote asset address\n   * @return id is the round ID for which data was retrieved\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed.\n  */\n  function proposedLatestRoundData(\n    address base,\n    address quote\n  )\n    external\n    view\n    virtual\n    override\n    hasProposal(base, quote)\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return s_proposedAggregators[base][quote].latestRoundData();\n  }\n\n  function getCurrentPhaseId(\n    address base,\n    address quote\n  )\n    external\n    view\n    override\n    returns (\n      uint16 currentPhaseId\n    )\n  {\n    return s_currentPhaseId[base][quote];\n  }\n\n  function _addPhase(\n    uint16 phase,\n    uint64 roundId\n  )\n    internal\n    pure\n    returns (\n      uint80\n    )\n  {\n    return uint80(uint256(phase) << PHASE_OFFSET | roundId);\n  }\n\n  function _parseIds(\n    uint256 roundId\n  )\n    internal\n    pure\n    returns (\n      uint16,\n      uint64\n    )\n  {\n    uint16 phaseId = uint16(roundId >> PHASE_OFFSET);\n    uint64 aggregatorRoundId = uint64(roundId);\n\n    return (phaseId, aggregatorRoundId);\n  }\n\n  function _addPhaseIds(\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound,\n      uint16 phaseId\n  )\n    internal\n    pure\n    returns (\n      uint80,\n      int256,\n      uint256,\n      uint256,\n      uint80\n    )\n  {\n    return (\n      _addPhase(phaseId, uint64(roundId)),\n      answer,\n      startedAt,\n      updatedAt,\n      _addPhase(phaseId, uint64(answeredInRound))\n    );\n  }\n\n  function _getPhase(\n    address base,\n    address quote,\n    uint16 phaseId\n  )\n    internal\n    view\n    returns (\n      Phase memory phase\n    )\n  {\n    return s_phases[base][quote][phaseId];\n  }\n\n  function _phaseExists(\n    Phase memory phase\n  )\n    internal\n    pure\n    returns (\n      bool\n    )\n  {\n    return phase.phaseId > 0;\n  }\n\n  function _getProposedFeed(\n    address base,\n    address quote\n  )\n    internal\n    view\n    returns (\n      AggregatorV2V3Interface proposedAggregator\n    )\n  {\n    return s_proposedAggregators[base][quote];\n  }\n\n  function _getPhaseFeed(\n    address base,\n    address quote,\n    uint16 phaseId\n  )\n    internal\n    view\n    returns (\n      AggregatorV2V3Interface aggregator\n    )\n  {\n    return s_phaseAggregators[base][quote][phaseId];\n  }\n\n  function _getFeed(\n    address base,\n    address quote\n  )\n    internal\n    view\n    returns (\n      AggregatorV2V3Interface aggregator\n    )\n  {\n    uint16 currentPhaseId = s_currentPhaseId[base][quote];\n    return _getPhaseFeed(base, quote, currentPhaseId);\n  }\n\n  function _setFeed(\n    address base,\n    address quote,\n    address newAggregator\n  )\n    internal\n    returns (\n      uint16 nextPhaseId,\n      address previousAggregator\n    )\n  {\n    require(newAggregator == address(s_proposedAggregators[base][quote]), \"Invalid proposed aggregator\");\n    AggregatorV2V3Interface currentAggregator = _getFeed(base, quote);\n    uint80 previousAggregatorEndingRoundId = _getLatestAggregatorRoundId(currentAggregator);\n    uint16 currentPhaseId = s_currentPhaseId[base][quote];\n    s_phases[base][quote][currentPhaseId].endingAggregatorRoundId = previousAggregatorEndingRoundId;\n\n    nextPhaseId = currentPhaseId + 1;\n    s_currentPhaseId[base][quote] = nextPhaseId;\n    s_phaseAggregators[base][quote][nextPhaseId] = AggregatorV2V3Interface(newAggregator);\n    uint80 startingRoundId = _getLatestAggregatorRoundId(AggregatorV2V3Interface(newAggregator));\n    s_phases[base][quote][nextPhaseId] = Phase(nextPhaseId, startingRoundId, 0);\n\n    return (nextPhaseId, address(currentAggregator));\n  }\n\n  function _getPreviousRoundId(\n    address base,\n    address quote,\n    uint16 phaseId,\n    uint80 roundId\n  )\n    internal\n    view\n    returns (\n      uint80\n    )\n  {\n    for (uint16 pid = phaseId; pid > 0; pid--) {\n      AggregatorV2V3Interface phaseAggregator = _getPhaseFeed(base, quote, pid);\n      (uint80 startingRoundId, uint80 endingRoundId) = _getPhaseRange(base, quote, pid);\n      if (address(phaseAggregator) == address(0)) continue;\n      if (roundId <= startingRoundId) continue;\n      if (roundId > startingRoundId && roundId <= endingRoundId) return roundId - 1;\n      if (roundId > endingRoundId) return endingRoundId;\n    }\n    return 0; // Round not found\n  }\n\n  function _getNextRoundId(\n    address base,\n    address quote,\n    uint16 phaseId,\n    uint80 roundId\n  )\n    internal\n    view\n    returns (\n      uint80\n    )\n  {\n    uint16 currentPhaseId = s_currentPhaseId[base][quote];\n    for (uint16 pid = phaseId; pid <= currentPhaseId; pid++) {\n      AggregatorV2V3Interface phaseAggregator = _getPhaseFeed(base, quote, pid);\n      (uint80 startingRoundId, uint80 endingRoundId) =\n        (pid == currentPhaseId) ? _getLatestRoundRange(base, quote, pid) : _getPhaseRange(base, quote, pid);\n      if (address(phaseAggregator) == address(0)) continue;\n      if (roundId >= endingRoundId) continue;\n      if (roundId >= startingRoundId && roundId < endingRoundId) return roundId + 1;\n      if (roundId < startingRoundId) return startingRoundId;\n    }\n    return 0; // Round not found\n  }\n\n  function _getPhaseRange(\n    address base,\n    address quote,\n    uint16 phaseId\n  )\n    internal\n    view\n    returns (\n      uint80 startingRoundId,\n      uint80 endingRoundId\n    )\n  {\n    Phase memory phase = _getPhase(base, quote, phaseId);\n    return (\n      _getStartingRoundId(phaseId, phase),\n      _getEndingRoundId(phaseId, phase)\n    );\n  }\n\n  function _getLatestRoundRange(\n    address base,\n    address quote,\n    uint16 currentPhaseId\n  )\n    internal\n    view\n    returns (\n      uint80 startingRoundId,\n      uint80 endingRoundId\n    )\n  {\n    Phase memory phase = s_phases[base][quote][currentPhaseId];\n    return (\n      _getStartingRoundId(currentPhaseId, phase),\n      _getLatestRoundId(base, quote, currentPhaseId)\n    );\n  }\n\n  function _getStartingRoundId(\n    uint16 phaseId,\n    Phase memory phase\n  )\n    internal\n    pure\n    returns (\n      uint80 startingRoundId\n    )\n  {\n    return _addPhase(phaseId, uint64(phase.startingAggregatorRoundId));\n  }\n\n  function _getEndingRoundId(\n    uint16 phaseId,\n    Phase memory phase\n  )\n    internal\n    pure\n    returns (\n      uint80 startingRoundId\n    )\n  {\n    return _addPhase(phaseId, uint64(phase.endingAggregatorRoundId));\n  }\n\n  function _getLatestRoundId(\n    address base,\n    address quote,\n    uint16 phaseId\n  )\n    internal\n    view\n    returns (\n      uint80 startingRoundId\n    )\n  {\n    AggregatorV2V3Interface currentPhaseAggregator = _getFeed(base, quote);\n    uint80 latestAggregatorRoundId = _getLatestAggregatorRoundId(currentPhaseAggregator);\n    return _addPhase(phaseId, uint64(latestAggregatorRoundId));\n  }\n\n  function _getLatestAggregatorRoundId(\n    AggregatorV2V3Interface aggregator\n  )\n    internal\n    view\n    returns (\n      uint80 roundId\n    )\n  {\n    if (address(aggregator) == address(0)) return uint80(0);\n    return uint80(aggregator.latestRound());\n  }\n\n  function _getPhaseIdByRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  )\n    internal\n    view\n    returns (\n      uint16 phaseId\n    )\n  {\n    // Handle case where the round is in current phase\n    uint16 currentPhaseId = s_currentPhaseId[base][quote];\n    (uint80 startingCurrentRoundId, uint80 endingCurrentRoundId) = _getLatestRoundRange(base, quote, currentPhaseId);\n    if (roundId >= startingCurrentRoundId && roundId <= endingCurrentRoundId) return currentPhaseId;\n\n    // Handle case where the round is in past phases\n    require(currentPhaseId > 0, \"Invalid phase\");\n    for (uint16 pid = currentPhaseId - 1; pid > 0; pid--) {\n      AggregatorV2V3Interface phaseAggregator = s_phaseAggregators[base][quote][pid];\n      if (address(phaseAggregator) == address(0)) continue;\n      (uint80 startingRoundId, uint80 endingRoundId) = _getPhaseRange(base, quote, pid);\n      if (roundId >= startingRoundId && roundId <= endingRoundId) return pid;\n      if (roundId > endingRoundId) break;\n    }\n    return 0;\n  }\n\n  /**\n   * @dev reverts if the caller does not have access granted by the accessController contract\n   * to the base / quote pair or is the contract itself.\n   */\n  modifier checkPairAccess() {\n    require(address(s_accessController) == address(0) || s_accessController.hasAccess(msg.sender, msg.data), \"No access\");\n    _;\n  }\n\n  /**\n   * @dev reverts if no proposed aggregator was set\n   */\n  modifier hasProposal(\n    address base,\n    address quote\n  ) {\n    require(address(s_proposedAggregators[base][quote]) != address(0), \"No proposed aggregator present\");\n    _;\n  }\n}\n"
        },
        "contracts/access/AccessControlled.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"@chainlink/contracts/src/v0.7/dev/ConfirmedOwner.sol\";\nimport \"../interfaces/AccessControlledInterface.sol\";\nimport \"../interfaces/AccessControllerInterface.sol\";\n\ncontract AccessControlled is AccessControlledInterface, ConfirmedOwner(msg.sender) {\n  AccessControllerInterface internal s_accessController;\n\n  function setAccessController(\n    AccessControllerInterface _accessController\n  )\n    public\n    override\n    onlyOwner()\n  {\n    require(address(_accessController) != address(s_accessController), \"Access controller is already set\");\n    s_accessController = _accessController;\n    emit AccessControllerSet(address(_accessController), msg.sender);\n  }\n\n  function getAccessController()\n    public\n    view\n    override\n    returns (\n      AccessControllerInterface\n    )\n  {\n    return s_accessController;\n  }\n}\n"
        },
        "contracts/interfaces/AccessControlledInterface.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./AccessControllerInterface.sol\";\n\ninterface AccessControlledInterface {\n  event AccessControllerSet(\n    address indexed accessController,\n    address indexed sender\n  );\n\n  function setAccessController(\n    AccessControllerInterface _accessController\n  )\n    external;\n\n  function getAccessController()\n    external\n    view\n    returns (\n      AccessControllerInterface\n    );\n}\n"
        },
        "contracts/interfaces/AccessControllerInterface.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface AccessControllerInterface {\n  function hasAccess(address user, bytes calldata data) external view returns (bool);\n}\n"
        },
        "contracts/interfaces/FeedRegistryInterface.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2; // solhint-disable compiler-version\n\nimport \"@chainlink/contracts/src/v0.7/interfaces/AggregatorV2V3Interface.sol\";\n\ninterface FeedRegistryInterface {\n  struct Phase {\n    uint16 phaseId;\n    uint80 startingAggregatorRoundId;\n    uint80 endingAggregatorRoundId;\n  }\n\n  event FeedProposed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed proposedAggregator,\n    address currentAggregator,\n    address sender\n  );\n  event FeedConfirmed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed latestAggregator,\n    address previousAggregator,\n    uint16 nextPhaseId,\n    address sender\n  );\n\n  // V3 AggregatorV3Interface\n\n  function decimals(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      uint256\n    );\n\n  function latestRoundData(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function getRoundData(\n    address base,\n    address quote,\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // V2 AggregatorInterface\n\n  function latestAnswer(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      int256 answer\n    );\n\n  function latestTimestamp(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      uint256 timestamp\n    );\n\n  function latestRound(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      uint256 roundId\n    );\n\n  function getAnswer(\n    address base,\n    address quote,\n    uint256 roundId\n  )\n    external\n    view\n    returns (\n      int256 answer\n    );\n\n  function getTimestamp(\n    address base,\n    address quote,\n    uint256 roundId\n  )\n    external\n    view\n    returns (\n      uint256 timestamp\n    );\n\n  // Registry getters\n\n  function getFeed(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      AggregatorV2V3Interface aggregator\n    );\n\n  function getPhaseFeed(\n    address base,\n    address quote,\n    uint16 phaseId\n  )\n    external\n    view\n    returns (\n      AggregatorV2V3Interface aggregator\n    );\n\n  function isFeedEnabled(\n    address aggregator\n  )\n    external\n    view\n    returns (\n      bool\n    );\n\n  function getPhase(\n    address base,\n    address quote,\n    uint16 phaseId\n  )\n    external\n    view\n    returns (\n      Phase memory phase\n    );\n\n  // Round helpers\n\n  function getRoundFeed(\n    address base,\n    address quote,\n    uint80 roundId\n  )\n    external\n    view\n    returns (\n      AggregatorV2V3Interface aggregator\n    );\n\n  function getPhaseRange(\n    address base,\n    address quote,\n    uint16 phaseId\n  )\n    external\n    view\n    returns (\n      uint80 startingRoundId,\n      uint80 endingRoundId\n    );\n\n  function getPreviousRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external\n    view\n    returns (\n      uint80 previousRoundId\n    );\n\n  function getNextRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external\n    view\n    returns (\n      uint80 nextRoundId\n    );\n\n  // Feed management\n\n  function proposeFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  function confirmFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  // Proposed aggregator\n\n  function getProposedFeed(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      AggregatorV2V3Interface proposedAggregator\n    );\n\n  function proposedGetRoundData(\n    address base,\n    address quote,\n    uint80 roundId\n  )\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function proposedLatestRoundData(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // Phases\n  function getCurrentPhaseId(\n    address base,\n    address quote\n  )\n    external\n    view\n    returns (\n      uint16 currentPhaseId\n    );\n}\n"
        },
        "contracts/interfaces/TypeAndVersionInterface.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface TypeAndVersionInterface{\n  function typeAndVersion()\n    external\n    pure\n    returns (\n      string memory\n    );\n}\n"
        }
    }
}
