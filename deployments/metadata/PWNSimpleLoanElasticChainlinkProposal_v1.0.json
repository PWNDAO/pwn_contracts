{
    "language": "Solidity",
    "settings": {
        "evmVersion": "london",
        "libraries": {},
        "metadata": {
            "bytecodeHash": "ipfs"
        },
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "remappings": [
            ":MultiToken/=lib/MultiToken/src/",
            ":ds-test/=lib/forge-std/lib/ds-test/src/",
            ":erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/",
            ":forge-std/=lib/forge-std/src/",
            ":multitoken/=lib/MultiToken/src/",
            ":openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
            ":openzeppelin-contracts/=lib/openzeppelin-contracts/",
            ":openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
            ":openzeppelin/=lib/openzeppelin-contracts/contracts/",
            ":pwn/=src/"
        ]
    },
    "sources": {
        "lib/MultiToken/src/MultiToken.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport { IERC20 } from \"openzeppelin/interfaces/IERC20.sol\";\r\nimport { IERC721 } from \"openzeppelin/interfaces/IERC721.sol\";\r\nimport { IERC1155 } from \"openzeppelin/interfaces/IERC1155.sol\";\r\nimport { IERC20Permit } from \"openzeppelin/token/ERC20/extensions/IERC20Permit.sol\";\r\nimport { SafeERC20 } from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\r\nimport { ERC165Checker } from \"openzeppelin/utils/introspection/ERC165Checker.sol\";\r\n\r\nimport { ICryptoKitties } from \"multitoken/interfaces/ICryptoKitties.sol\";\r\nimport { IMultiTokenCategoryRegistry } from \"multitoken/interfaces/IMultiTokenCategoryRegistry.sol\";\r\n\r\n\r\n/**\r\n * @title MultiToken library\r\n * @dev Library for handling various token standards (ERC20, ERC721, ERC1155, CryptoKitties) in a single contract.\r\n */\r\nlibrary MultiToken {\r\n    using ERC165Checker for address;\r\n    using SafeERC20 for IERC20;\r\n\r\n    bytes4 public constant ERC20_INTERFACE_ID = 0x36372b07;\r\n    bytes4 public constant ERC721_INTERFACE_ID = 0x80ac58cd;\r\n    bytes4 public constant ERC1155_INTERFACE_ID = 0xd9b67a26;\r\n    bytes4 public constant CRYPTO_KITTIES_INTERFACE_ID = 0x9a20483d;\r\n\r\n    /**\r\n    * @notice A reserved value for a category not registered.\r\n    */\r\n    uint8 public constant CATEGORY_NOT_REGISTERED = type(uint8).max;\r\n\r\n    /**\r\n     * @title Category\r\n     * @dev Enum representation Asset category.\r\n     */\r\n    enum Category {\r\n        ERC20,\r\n        ERC721,\r\n        ERC1155,\r\n        CryptoKitties\r\n    }\r\n\r\n    /**\r\n     * @title Asset\r\n     * @param category Corresponding asset category.\r\n     * @param assetAddress Address of the token contract defining the asset.\r\n     * @param id TokenID of an NFT or 0.\r\n     * @param amount Amount of fungible tokens or 0 -\u003e 1.\r\n     */\r\n    struct Asset {\r\n        Category category;\r\n        address assetAddress;\r\n        uint256 id;\r\n        uint256 amount;\r\n    }\r\n\r\n    /**\r\n     * @notice Thrown when unsupported category is used.\r\n     * @param categoryValue Value of the unsupported category.\r\n     */\r\n    error UnsupportedCategory(uint8 categoryValue);\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # FACTORY FUNCTIONS                                     *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Factory function for creating an ERC20 asset.\r\n     * @param assetAddress Address of the token contract defining the asset.\r\n     * @param amount Amount of fungible tokens.\r\n     * @return Asset struct representing the ERC20 asset.\r\n     */\r\n    function ERC20(address assetAddress, uint256 amount) internal pure returns (Asset memory) {\r\n        return Asset(Category.ERC20, assetAddress, 0, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Factory function for creating an ERC721 asset.\r\n     * @param assetAddress Address of the token contract defining the asset.\r\n     * @param id Token id of an NFT.\r\n     * @return Asset struct representing the ERC721 asset.\r\n     */\r\n    function ERC721(address assetAddress, uint256 id) internal pure returns (Asset memory) {\r\n        return Asset(Category.ERC721, assetAddress, id, 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Factory function for creating an ERC1155 asset.\r\n     * @param assetAddress Address of the token contract defining the asset.\r\n     * @param id Token id of an SFT.\r\n     * @param amount Amount of semifungible tokens.\r\n     * @return Asset struct representing the ERC1155 asset.\r\n     */\r\n    function ERC1155(address assetAddress, uint256 id, uint256 amount) internal pure returns (Asset memory) {\r\n        return Asset(Category.ERC1155, assetAddress, id, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Factory function for creating an ERC1155 NFT asset.\r\n     * @param assetAddress Address of the token contract defining the asset.\r\n     * @param id Token id of an NFT.\r\n     * @return Asset struct representing the ERC1155 NFT asset.\r\n     */\r\n    function ERC1155(address assetAddress, uint256 id) internal pure returns (Asset memory) {\r\n        return Asset(Category.ERC1155, assetAddress, id, 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Factory function for creating a CryptoKitties asset.\r\n     * @param assetAddress Address of the token contract defining the asset.\r\n     * @param id Token id of a CryptoKitty.\r\n     * @return Asset struct representing the CryptoKitties asset.\r\n     */\r\n    function CryptoKitties(address assetAddress, uint256 id) internal pure returns (Asset memory) {\r\n        return Asset(Category.CryptoKitties, assetAddress, id, 0);\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # TRANSFER ASSET                                        *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Wrapping function for `transferFrom` calls on various token interfaces.\r\n     * @dev If `source` is `address(this)`, function `transfer` is called instead of `transferFrom` for ERC20 category.\r\n     * @param asset Struct defining all necessary context of a token.\r\n     * @param source Account/address that provided the allowance.\r\n     * @param dest Destination address.\r\n     */\r\n    function transferAssetFrom(Asset memory asset, address source, address dest) internal {\r\n        _transferAssetFrom(asset, source, dest, false);\r\n    }\r\n\r\n    /**\r\n     * @notice Wrapping function for `safeTransferFrom` calls on various token interfaces.\r\n     * @dev If `source` is `address(this)`, function `transfer` is called instead of `transferFrom` for ERC20 category.\r\n     * @param asset Struct defining all necessary context of a token.\r\n     * @param source Account/address that provided the allowance.\r\n     * @param dest Destination address.\r\n     */\r\n    function safeTransferAssetFrom(Asset memory asset, address source, address dest) internal {\r\n        _transferAssetFrom(asset, source, dest, true);\r\n    }\r\n\r\n    function _transferAssetFrom(Asset memory asset, address source, address dest, bool isSafe) private {\r\n        if (asset.category == Category.ERC20) {\r\n            if (source == address(this))\r\n                IERC20(asset.assetAddress).safeTransfer(dest, asset.amount);\r\n            else\r\n                IERC20(asset.assetAddress).safeTransferFrom(source, dest, asset.amount);\r\n\r\n        } else if (asset.category == Category.ERC721) {\r\n            if (!isSafe)\r\n                IERC721(asset.assetAddress).transferFrom(source, dest, asset.id);\r\n            else\r\n                IERC721(asset.assetAddress).safeTransferFrom(source, dest, asset.id, \"\");\r\n\r\n        } else if (asset.category == Category.ERC1155) {\r\n            IERC1155(asset.assetAddress).safeTransferFrom(source, dest, asset.id, asset.amount == 0 ? 1 : asset.amount, \"\");\r\n\r\n        } else if (asset.category == Category.CryptoKitties) {\r\n            if (source == address(this))\r\n                ICryptoKitties(asset.assetAddress).transfer(dest, asset.id);\r\n            else\r\n                ICryptoKitties(asset.assetAddress).transferFrom(source, dest, asset.id);\r\n\r\n        } else {\r\n            revert(\"MultiToken: Unsupported category\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get amount of asset that would be transferred.\r\n     * @dev NFTs (ERC721, CryptoKitties \u0026 ERC1155 with amount 0) with return 1.\r\n     *      Fungible tokens will return its amount (ERC20 with 0 amount is valid).\r\n     *      In combination with `balanceOf` can be used to check successful asset transfer.\r\n     * @param asset Struct defining all necessary context of a token.\r\n     * @return Number of tokens that would be transferred of the asset.\r\n     */\r\n    function getTransferAmount(Asset memory asset) internal pure returns (uint256) {\r\n        if (asset.category == Category.ERC20)\r\n            return asset.amount;\r\n        else if (asset.category == Category.ERC1155 \u0026\u0026 asset.amount \u003e 0)\r\n            return asset.amount;\r\n        else // Return 1 for ERC721, CryptoKitties and ERC1155 used as NFTs (amount = 0)\r\n            return 1;\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # TRANSFER ASSET CALLDATA                               *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Wrapping function for `transferFrom` calladata on various token interfaces.\r\n     * @dev If `fromSender` is true, function `transfer` is returned instead of `transferFrom` for ERC20 category.\r\n     * @param asset Struct defining all necessary context of a token.\r\n     * @param source Account/address that provided the allowance.\r\n     * @param dest Destination address.\r\n     */\r\n    function transferAssetFromCalldata(Asset memory asset, address source, address dest, bool fromSender) pure internal returns (bytes memory) {\r\n        return _transferAssetFromCalldata(asset, source, dest, fromSender, false);\r\n    }\r\n\r\n    /**\r\n     * @notice Wrapping function for `safeTransferFrom` calladata on various token interfaces.\r\n     * @dev If `fromSender` is true, function `transfer` is returned instead of `transferFrom` for ERC20 category.\r\n     * @param asset Struct defining all necessary context of a token.\r\n     * @param source Account/address that provided the allowance.\r\n     * @param dest Destination address.\r\n     */\r\n    function safeTransferAssetFromCalldata(Asset memory asset, address source, address dest, bool fromSender) pure internal returns (bytes memory) {\r\n        return _transferAssetFromCalldata(asset, source, dest, fromSender, true);\r\n    }\r\n\r\n    function _transferAssetFromCalldata(Asset memory asset, address source, address dest, bool fromSender, bool isSafe) pure private returns (bytes memory) {\r\n        if (asset.category == Category.ERC20) {\r\n            if (fromSender) {\r\n                return abi.encodeWithSignature(\r\n                    \"transfer(address,uint256)\", dest, asset.amount\r\n                );\r\n            } else {\r\n                return abi.encodeWithSignature(\r\n                    \"transferFrom(address,address,uint256)\", source, dest, asset.amount\r\n                );\r\n            }\r\n        } else if (asset.category == Category.ERC721) {\r\n            if (!isSafe) {\r\n                return abi.encodeWithSignature(\r\n                    \"transferFrom(address,address,uint256)\", source, dest, asset.id\r\n                );\r\n            } else {\r\n                return abi.encodeWithSignature(\r\n                    \"safeTransferFrom(address,address,uint256,bytes)\", source, dest, asset.id, \"\"\r\n                );\r\n            }\r\n\r\n        } else if (asset.category == Category.ERC1155) {\r\n            return abi.encodeWithSignature(\r\n                \"safeTransferFrom(address,address,uint256,uint256,bytes)\", source, dest, asset.id, asset.amount == 0 ? 1 : asset.amount, \"\"\r\n            );\r\n\r\n        } else if (asset.category == Category.CryptoKitties) {\r\n            if (fromSender) {\r\n                return abi.encodeWithSignature(\r\n                    \"transfer(address,uint256)\", dest, asset.id\r\n                );\r\n            } else {\r\n                return abi.encodeWithSignature(\r\n                    \"transferFrom(address,address,uint256)\", source, dest, asset.id\r\n                );\r\n            }\r\n\r\n        } else {\r\n            revert(\"MultiToken: Unsupported category\");\r\n        }\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # PERMIT                                                *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Wrapping function for granting approval via permit signature.\r\n     * @param asset Struct defining all necessary context of a token.\r\n     * @param owner Account/address that signed the permit.\r\n     * @param spender Account/address that would be granted approval to `asset`.\r\n     * @param permitData Data about permit deadline (uint256) and permit signature (64/65 bytes).\r\n     *                   Deadline and signature should be pack encoded together.\r\n     *                   Signature can be standard (65 bytes) or compact (64 bytes) defined in EIP-2098.\r\n     */\r\n    function permit(Asset memory asset, address owner, address spender, bytes memory permitData) internal {\r\n        if (asset.category == Category.ERC20) {\r\n\r\n            // Parse deadline and permit signature parameters\r\n            uint256 deadline;\r\n            bytes32 r;\r\n            bytes32 s;\r\n            uint8 v;\r\n\r\n            // Parsing signature parameters used from OpenZeppelins ECDSA library\r\n            // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/83277ff916ac4f58fec072b8f28a252c1245c2f1/contracts/utils/cryptography/ECDSA.sol\r\n\r\n            // Deadline (32 bytes) + standard signature data (65 bytes) -\u003e 97 bytes\r\n            if (permitData.length == 97) {\r\n                assembly {\r\n                    deadline := mload(add(permitData, 0x20))\r\n                    r := mload(add(permitData, 0x40))\r\n                    s := mload(add(permitData, 0x60))\r\n                    v := byte(0, mload(add(permitData, 0x80)))\r\n                }\r\n            }\r\n            // Deadline (32 bytes) + compact signature data (64 bytes) -\u003e 96 bytes\r\n            else if (permitData.length == 96) {\r\n                bytes32 vs;\r\n\r\n                assembly {\r\n                    deadline := mload(add(permitData, 0x20))\r\n                    r := mload(add(permitData, 0x40))\r\n                    vs := mload(add(permitData, 0x60))\r\n                }\r\n\r\n                s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n                v = uint8((uint256(vs) \u003e\u003e 255) + 27);\r\n            } else {\r\n                revert(\"MultiToken::Permit: Invalid permit length\");\r\n            }\r\n\r\n            // Call permit with parsed parameters\r\n            IERC20Permit(asset.assetAddress).permit(owner, spender, asset.amount, deadline, v, r, s);\r\n\r\n        } else {\r\n            // Currently supporting only ERC20 signed approvals via ERC2612\r\n            revert(\"MultiToken::Permit: Unsupported category\");\r\n        }\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # BALANCE OF                                            *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Wrapping function for checking balances on various token interfaces.\r\n     * @param asset Struct defining all necessary context of a token.\r\n     * @param target Target address to be checked.\r\n     */\r\n    function balanceOf(Asset memory asset, address target) internal view returns (uint256) {\r\n        if (asset.category == Category.ERC20) {\r\n            return IERC20(asset.assetAddress).balanceOf(target);\r\n\r\n        } else if (asset.category == Category.ERC721) {\r\n            return IERC721(asset.assetAddress).ownerOf(asset.id) == target ? 1 : 0;\r\n\r\n        } else if (asset.category == Category.ERC1155) {\r\n            return IERC1155(asset.assetAddress).balanceOf(target, asset.id);\r\n\r\n        } else if (asset.category == Category.CryptoKitties) {\r\n            return ICryptoKitties(asset.assetAddress).ownerOf(asset.id) == target ? 1 : 0;\r\n\r\n        } else {\r\n            revert(\"MultiToken: Unsupported category\");\r\n        }\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # APPROVE ASSET                                         *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Wrapping function for `approve` calls on various token interfaces.\r\n     * @dev By using `safeApprove` for ERC20, caller can set allowance to 0 or from 0.\r\n     *      Cannot set non-zero value if allowance is also non-zero.\r\n     * @param asset Struct defining all necessary context of a token.\r\n     * @param target Account/address that would be granted approval to `asset`.\r\n     */\r\n    function approveAsset(Asset memory asset, address target) internal {\r\n        if (asset.category == Category.ERC20) {\r\n            IERC20(asset.assetAddress).safeApprove(target, asset.amount);\r\n\r\n        } else if (asset.category == Category.ERC721) {\r\n            IERC721(asset.assetAddress).approve(target, asset.id);\r\n\r\n        } else if (asset.category == Category.ERC1155) {\r\n            IERC1155(asset.assetAddress).setApprovalForAll(target, true);\r\n\r\n        } else if (asset.category == Category.CryptoKitties) {\r\n            ICryptoKitties(asset.assetAddress).approve(target, asset.id);\r\n\r\n        } else {\r\n            revert(\"MultiToken: Unsupported category\");\r\n        }\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # ASSET CHECKS                                          *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Checks that provided asset is contract, has correct format and stated category via MultiTokenCategoryRegistry and ERC165 checks.\r\n     * @dev Fungible tokens (ERC20) have to have id = 0.\r\n     *      NFT (ERC721, CryptoKitties) tokens have to have amount = 0.\r\n     *      Correct asset category is determined via ERC165.\r\n     *      The check assumes, that asset contract implements only one token standard at a time.\r\n     * @param registry Category registry contract.\r\n     * @param asset Asset that is examined.\r\n     * @return True if asset has correct format and category.\r\n     */\r\n    function isValid(Asset memory asset, IMultiTokenCategoryRegistry registry) internal view returns (bool) {\r\n        return _checkCategory(asset, registry) \u0026\u0026 _checkFormat(asset);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks that provided asset is contract, has correct format and stated category via ERC165 checks.\r\n     * @dev Fungible tokens (ERC20) have to have id = 0.\r\n     *      NFT (ERC721, CryptoKitties) tokens have to have amount = 0.\r\n     *      Correct asset category is determined via ERC165.\r\n     *      The check assumes, that asset contract implements only one token standard at a time.\r\n     * @param asset Asset that is examined.\r\n     * @return True if asset has correct format and category.\r\n     */\r\n    function isValid(Asset memory asset) internal view returns (bool) {\r\n        return _checkCategoryViaERC165(asset) \u0026\u0026 _checkFormat(asset);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks that provided asset is contract and stated category is correct via MultiTokenCategoryRegistry and ERC165 checks.\r\n     * @dev Will fallback to ERC165 checks if asset is not registered in the category registry.\r\n     *      The check assumes, that asset contract implements only one token standard at a time.\r\n     * @param registry Category registry contract.\r\n     * @param asset Asset that is examined.\r\n     * @return True if assets stated category is correct.\r\n     */\r\n    function _checkCategory(Asset memory asset, IMultiTokenCategoryRegistry registry) internal view returns (bool) {\r\n        // Check if asset is registered in the category registry\r\n        uint8 categoryValue = registry.registeredCategoryValue(asset.assetAddress);\r\n        if (categoryValue != CATEGORY_NOT_REGISTERED)\r\n            return uint8(asset.category) == categoryValue;\r\n\r\n        return _checkCategoryViaERC165(asset);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks that provided asset is contract and stated category is correct via ERC165 checks.\r\n     * @dev The check assumes, that asset contract implements only one token standard at a time.\r\n     * @param asset Asset that is examined.\r\n     * @return True if assets stated category is correct.\r\n     */\r\n    function _checkCategoryViaERC165(Asset memory asset) internal view returns (bool) {\r\n        if (asset.category == Category.ERC20) {\r\n            // ERC20 has optional ERC165 implementation\r\n            if (asset.assetAddress.supportsERC165()) {\r\n                // If contract implements ERC165 and returns true for ERC20 intefrace id, consider it a correct category\r\n                if (asset.assetAddress.supportsERC165InterfaceUnchecked(ERC20_INTERFACE_ID))\r\n                    return true;\r\n\r\n                // If contract implements ERC165, it has to return false for ERC721, ERC1155, and CryptoKitties interface ids\r\n                return\r\n                    !asset.assetAddress.supportsERC165InterfaceUnchecked(ERC721_INTERFACE_ID) \u0026\u0026\r\n                    !asset.assetAddress.supportsERC165InterfaceUnchecked(ERC1155_INTERFACE_ID) \u0026\u0026\r\n                    !asset.assetAddress.supportsERC165InterfaceUnchecked(CRYPTO_KITTIES_INTERFACE_ID);\r\n\r\n            } else {\r\n                // In case token doesn\u0027t implement ERC165, its safe to assume that provided category is correct,\r\n                // because any other category has to implement ERC165.\r\n\r\n                // Check that asset address is contract\r\n                // Note: Asset address will return code length 0, if this code is called from the constructor.\r\n                return asset.assetAddress.code.length \u003e 0;\r\n            }\r\n\r\n        } else if (asset.category == Category.ERC721) {\r\n            // Check ERC721 via ERC165\r\n            return asset.assetAddress.supportsInterface(ERC721_INTERFACE_ID);\r\n\r\n        } else if (asset.category == Category.ERC1155) {\r\n            // Check ERC1155 via ERC165\r\n            return asset.assetAddress.supportsInterface(ERC1155_INTERFACE_ID);\r\n\r\n        } else if (asset.category == Category.CryptoKitties) {\r\n            // Check CryptoKitties via ERC165\r\n            return asset.assetAddress.supportsInterface(CRYPTO_KITTIES_INTERFACE_ID);\r\n\r\n        } else {\r\n            revert UnsupportedCategory(uint8(asset.category));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks that provided asset has correct format.\r\n     * @dev Fungible tokens (ERC20) have to have id = 0.\r\n     *      NFT (ERC721, CryptoKitties) tokens have to have amount = 0.\r\n     *      Correct asset category is determined via ERC165.\r\n     * @param asset Asset that is examined.\r\n     * @return True asset struct has correct format.\r\n     */\r\n    function _checkFormat(Asset memory asset) internal pure returns (bool) {\r\n        if (asset.category == Category.ERC20) {\r\n            // Id must be 0 for ERC20\r\n            if (asset.id != 0) return false;\r\n\r\n        } else if (asset.category == Category.ERC721) {\r\n            // Amount must be 0 for ERC721\r\n            if (asset.amount != 0) return false;\r\n\r\n        } else if (asset.category == Category.ERC1155) {\r\n            // No format check for ERC1155\r\n\r\n        } else if (asset.category == Category.CryptoKitties) {\r\n            // Amount must be 0 for CryptoKitties\r\n            if (asset.amount != 0) return false;\r\n\r\n        } else {\r\n            revert UnsupportedCategory(uint8(asset.category));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Compare two assets, ignoring their amounts.\r\n     * @param asset First asset to examine.\r\n     * @param otherAsset Second asset to examine.\r\n     * @return True if both structs represents the same asset.\r\n     */\r\n    function isSameAs(Asset memory asset, Asset memory otherAsset) internal pure returns (bool) {\r\n        return\r\n            asset.category == otherAsset.category \u0026\u0026\r\n            asset.assetAddress == otherAsset.assetAddress \u0026\u0026\r\n            asset.id == otherAsset.id;\r\n    }\r\n\r\n}\r\n"
        },
        "lib/MultiToken/src/interfaces/ICryptoKitties.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title CryptoKitties Interface\r\n * @dev CryptoKitties Interface ID is 0x9a20483d.\r\n */\r\ninterface ICryptoKitties {\r\n    // Required methods\r\n    function totalSupply() external view returns (uint256 total);\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    // Optional\r\n    function name() external view returns (string memory name);\r\n    function symbol() external view returns (string memory symbol);\r\n    function tokensOfOwner(address _owner) external view returns (uint256[] memory tokenIds);\r\n    function tokenMetadata(uint256 _tokenId, string memory _preferredTransport) external view returns (string memory infoUrl);\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\r\n    // Is not part of the interface id\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\r\n}\r\n"
        },
        "lib/MultiToken/src/interfaces/IMultiTokenCategoryRegistry.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n* @title MultiToken Category Registry Interface\r\n* @notice Interface for the MultiToken Category Registry.\r\n* @dev Category Registry Interface ID is 0xc37a4a01.\r\n*/\r\ninterface IMultiTokenCategoryRegistry {\r\n\r\n    /**\r\n    * @notice Emitted when a category is registered for an asset address.\r\n    * @param assetAddress Address of an asset to which category is registered.\r\n    * @param category A raw value of a MultiToken Category registered for an asset.\r\n    */\r\n    event CategoryRegistered(address indexed assetAddress, uint8 indexed category);\r\n\r\n    /**\r\n    * @notice Emitted when a category is unregistered for an asset address.\r\n    * @param assetAddress Address of an asset to which category is unregistered.\r\n    */\r\n    event CategoryUnregistered(address indexed assetAddress);\r\n\r\n    /**\r\n     * @notice Register a MultiToken Category value to an asset address.\r\n     * @param assetAddress Address of an asset to which category is registered.\r\n     * @param category A raw value of a MultiToken Category to register for an asset.\r\n     */\r\n    function registerCategoryValue(address assetAddress, uint8 category) external;\r\n\r\n    /**\r\n     * @notice Clear the stored category for the asset address.\r\n     * @param assetAddress Address of an asset to which category is unregistered.\r\n     */\r\n    function unregisterCategoryValue(address assetAddress) external;\r\n\r\n    /**\r\n     * @notice Getter for a registered category value of a given asset address.\r\n     * @param assetAddress Address of an asset to which category is requested.\r\n     * @return Raw category value registered for the asset address.\r\n     */\r\n    function registeredCategoryValue(address assetAddress) external view returns (uint8);\r\n\r\n}\r\n"
        },
        "lib/openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./OwnableUpgradeable.sol\";\r\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership} and {acceptOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available all functions\r\n * from parent (Ownable).\r\n */\r\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\r\n    address private _pendingOwner;\r\n\r\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function __Ownable2Step_init() internal onlyInitializing {\r\n        __Ownable_init_unchained();\r\n    }\r\n\r\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\r\n    }\r\n    /**\r\n     * @dev Returns the address of the pending owner.\r\n     */\r\n    function pendingOwner() public view virtual returns (address) {\r\n        return _pendingOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\r\n        _pendingOwner = newOwner;\r\n        emit OwnershipTransferStarted(owner(), newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual override {\r\n        delete _pendingOwner;\r\n        super._transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev The new owner accepts the ownership transfer.\r\n     */\r\n    function acceptOwnership() public virtual {\r\n        address sender = _msgSender();\r\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\r\n        _transferOwnership(sender);\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n}\r\n"
        },
        "lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../utils/ContextUpgradeable.sol\";\r\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init() internal onlyInitializing {\r\n        __Ownable_init_unchained();\r\n    }\r\n\r\n    function __Ownable_init_unchained() internal onlyInitializing {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n}\r\n"
        },
        "lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\r\n\r\npragma solidity ^0.8.2;\r\n\r\nimport \"../../utils/AddressUpgradeable.sol\";\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since proxied contracts do not make use of a constructor, it\u0027s common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\r\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\r\n * case an upgrade adds a module that needs to be initialized.\r\n *\r\n * For example:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```solidity\r\n * contract MyToken is ERC20Upgradeable {\r\n *     function initialize() initializer public {\r\n *         __ERC20_init(\"MyToken\", \"MTK\");\r\n *     }\r\n * }\r\n *\r\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\r\n *     function initializeV2() reinitializer(2) public {\r\n *         __ERC20Permit_init(\"MyToken\");\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\r\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() {\r\n *     _disableInitializers();\r\n * }\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     * @custom:oz-retyped-from bool\r\n     */\r\n    uint8 private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Triggered when the contract has been initialized or reinitialized.\r\n     */\r\n    event Initialized(uint8 version);\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\r\n     * `onlyInitializing` functions can be used to initialize parent contracts.\r\n     *\r\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\r\n     * constructor.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier initializer() {\r\n        bool isTopLevelCall = !_initializing;\r\n        require(\r\n            (isTopLevelCall \u0026\u0026 _initialized \u003c 1) || (!AddressUpgradeable.isContract(address(this)) \u0026\u0026 _initialized == 1),\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n        _initialized = 1;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n        }\r\n        _;\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n            emit Initialized(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\r\n     * contract hasn\u0027t been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\r\n     * used to initialize parent contracts.\r\n     *\r\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\r\n     * are added through upgrades and that require initialization.\r\n     *\r\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\r\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\r\n     *\r\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\r\n     * a contract, executing them in the right order is up to the developer or operator.\r\n     *\r\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier reinitializer(uint8 version) {\r\n        require(!_initializing \u0026\u0026 _initialized \u003c version, \"Initializable: contract is already initialized\");\r\n        _initialized = version;\r\n        _initializing = true;\r\n        _;\r\n        _initializing = false;\r\n        emit Initialized(version);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\r\n     */\r\n    modifier onlyInitializing() {\r\n        require(_initializing, \"Initializable: contract is not initializing\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\r\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\r\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\r\n     * through proxies.\r\n     *\r\n     * Emits an {Initialized} event the first time it is successfully executed.\r\n     */\r\n    function _disableInitializers() internal virtual {\r\n        require(!_initializing, \"Initializable: contract is initializing\");\r\n        if (_initialized != type(uint8).max) {\r\n            _initialized = type(uint8).max;\r\n            emit Initialized(type(uint8).max);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\r\n     */\r\n    function _getInitializedVersion() internal view returns (uint8) {\r\n        return _initialized;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\r\n     */\r\n    function _isInitializing() internal view returns (bool) {\r\n        return _initializing;\r\n    }\r\n}\r\n"
        },
        "lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary AddressUpgradeable {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn\u0027t rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length \u003e 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\u0027t, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length \u003e 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n"
        },
        "lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal onlyInitializing {\r\n    }\r\n\r\n    function __Context_init_unchained() internal onlyInitializing {\r\n    }\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _contextSuffixLength() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[50] private __gap;\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../utils/Context.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Ownable.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership} and {acceptOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available all functions\r\n * from parent (Ownable).\r\n */\r\nabstract contract Ownable2Step is Ownable {\r\n    address private _pendingOwner;\r\n\r\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Returns the address of the pending owner.\r\n     */\r\n    function pendingOwner() public view virtual returns (address) {\r\n        return _pendingOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\r\n        _pendingOwner = newOwner;\r\n        emit OwnershipTransferStarted(owner(), newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual override {\r\n        delete _pendingOwner;\r\n        super._transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev The new owner accepts the ownership transfer.\r\n     */\r\n    function acceptOwnership() public virtual {\r\n        address sender = _msgSender();\r\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\r\n        _transferOwnership(sender);\r\n    }\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/interfaces/IERC1155.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1155.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../token/ERC1155/IERC1155.sol\";\r\n"
        },
        "lib/openzeppelin-contracts/contracts/interfaces/IERC1271.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC1271 standard signature validation method for\r\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC1271 {\r\n    /**\r\n     * @dev Should return whether the signature provided is valid for the provided data\r\n     * @param hash      Hash of the data to be signed\r\n     * @param signature Signature byte array associated with _data\r\n     */\r\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../token/ERC20/IERC20.sol\";\r\n"
        },
        "lib/openzeppelin-contracts/contracts/interfaces/IERC721.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../token/ERC721/IERC721.sol\";\r\n"
        },
        "lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler\u0027s defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../utils/introspection/IERC165.sol\";\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(\r\n        address[] calldata accounts,\r\n        uint256[] calldata ids\r\n    ) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller\u0027s tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``\u0027s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must have been approved to spend ``from``\u0027s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../utils/introspection/IERC165.sol\";\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\r\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *\r\n     * NOTE: To accept the transfer, this must return\r\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     * (i.e. 0xf23a6e61, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param id The ID of the token being transferred\r\n     * @param value The amount of tokens being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\r\n     * been updated.\r\n     *\r\n     * NOTE: To accept the transfer(s), this must return\r\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     * (i.e. 0xbc197c81, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account\u0027s ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn\u0027t\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n *\r\n * ==== Security Considerations\r\n *\r\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\r\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\r\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\r\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\r\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\r\n * generally recommended is:\r\n *\r\n * ```solidity\r\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\r\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\r\n *     doThing(..., value);\r\n * }\r\n *\r\n * function doThing(..., uint256 value) public {\r\n *     token.safeTransferFrom(msg.sender, address(this), value);\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\r\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\r\n * {SafeERC20-safeTransferFrom}).\r\n *\r\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\r\n * contracts should have entry points that don\u0027t rely on permit.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``\u0027s tokens,\r\n     * given ``owner``\u0027s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``\u0027s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     *\r\n     * CAUTION: See Security Considerations above.\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``\u0027s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../IERC20.sol\";\r\nimport \"../extensions/IERC20Permit.sol\";\r\nimport \"../../../utils/Address.sol\";\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\r\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the calling contract\u0027s allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the calling contract\u0027s allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set the calling contract\u0027s allowance toward `spender` to `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\r\n     * to be set to zero before setting it to a non-zero value, such as USDT.\r\n     */\r\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\r\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\r\n\r\n        if (!_callOptionalReturnBool(token, approvalCall)) {\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\r\n            _callOptionalReturn(token, approvalCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\r\n     * Revert on invalid signature.\r\n     */\r\n    function safePermit(\r\n        IERC20Permit token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\r\n        // we\u0027re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     *\r\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\r\n     */\r\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\r\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\r\n        // we\u0027re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\r\n        // and not revert is the subcall reverts.\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        return\r\n            success \u0026\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))) \u0026\u0026 Address.isContract(address(token));\r\n    }\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC721.sol\";\r\nimport \"./IERC721Receiver.sol\";\r\nimport \"./extensions/IERC721Metadata.sol\";\r\nimport \"../../utils/Address.sol\";\r\nimport \"../../utils/Context.sol\";\r\nimport \"../../utils/Strings.sol\";\r\nimport \"../../utils/introspection/ERC165.sol\";\r\n\r\n/**\r\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\r\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\r\n * {ERC721Enumerable}.\r\n */\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\r\n    using Address for address;\r\n    using Strings for uint256;\r\n\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Mapping from token ID to owner address\r\n    mapping(uint256 =\u003e address) private _owners;\r\n\r\n    // Mapping owner address to token count\r\n    mapping(address =\u003e uint256) private _balances;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint256 =\u003e address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address =\u003e mapping(address =\u003e bool)) private _operatorApprovals;\r\n\r\n    /**\r\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        address owner = _ownerOf(tokenId);\r\n        require(owner != address(0), \"ERC721: invalid token ID\");\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        _requireMinted(tokenId);\r\n\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length \u003e 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, can be overridden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(\r\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \"ERC721: approve caller is not token owner or approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        _requireMinted(tokenId);\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _setApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-transferFrom}.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\r\n        _safeTransfer(from, to, tokenId, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\r\n     *\r\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\u0027t exist\r\n     */\r\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\r\n        return _owners[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     * and stop existing when they are burned (`_burn`).\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _ownerOf(tokenId) != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n     */\r\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(address(0), to, tokenId, data),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\r\n\r\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        unchecked {\r\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\r\n            // Given that tokens are minted one by one, it is impossible in practice that\r\n            // this ever happens. Might change if we allow batch minting.\r\n            // The ERC fails to describe this case.\r\n            _balances[to] += 1;\r\n        }\r\n\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n\r\n        _afterTokenTransfer(address(0), to, tokenId, 1);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     * The approval is cleared when the token is burned.\r\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n\r\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\r\n\r\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\r\n        owner = ERC721.ownerOf(tokenId);\r\n\r\n        // Clear approvals\r\n        delete _tokenApprovals[tokenId];\r\n\r\n        unchecked {\r\n            // Cannot overflow, as that would require more tokens to be burned/transferred\r\n            // out than the owner initially received through minting and transferring in.\r\n            _balances[owner] -= 1;\r\n        }\r\n        delete _owners[tokenId];\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n\r\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\r\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, tokenId, 1);\r\n\r\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\r\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\r\n\r\n        // Clear approvals from the previous owner\r\n        delete _tokenApprovals[tokenId];\r\n\r\n        unchecked {\r\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\r\n            // `from`\u0027s balance is the number of token held, which is at least one before the current\r\n            // transfer.\r\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\r\n            // all 2**256 token ids to be minted, which in practice is impossible.\r\n            _balances[from] -= 1;\r\n            _balances[to] += 1;\r\n        }\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n\r\n        _afterTokenTransfer(from, to, tokenId, 1);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `to` to operate on `tokenId`\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `operator` to operate on all of `owner` tokens\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\r\n        require(owner != operator, \"ERC721: approve to caller\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if the `tokenId` has not been minted yet.\r\n     */\r\n    function _requireMinted(uint256 tokenId) internal view virtual {\r\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) private returns (bool) {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    /// @solidity memory-safe-assembly\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\r\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``\u0027s tokens will be transferred to `to`.\r\n     * - When `from` is zero, the tokens will be minted for `to`.\r\n     * - When `to` is zero, ``from``\u0027s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     * - `batchSize` is non-zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\r\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``\u0027s tokens were transferred to `to`.\r\n     * - When `from` is zero, the tokens were minted for `to`.\r\n     * - When `to` is zero, ``from``\u0027s tokens were burned.\r\n     * - `from` and `to` are never both zero.\r\n     * - `batchSize` is non-zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\r\n\r\n    /**\r\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\r\n     *\r\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\r\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\r\n     * that `ownerOf(tokenId)` is `a`.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\r\n        _balances[account] += amount;\r\n    }\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../utils/introspection/IERC165.sol\";\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``\u0027s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\r\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\r\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../IERC721.sol\";\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/Address.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn\u0027t rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length \u003e 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\u0027t, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length \u003e 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _contextSuffixLength() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/Strings.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./math/Math.sol\";\r\nimport \"./math/SignedMath.sol\";\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\r\n    uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = Math.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(int256 value) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            return toHexString(value, Math.log256(value) + 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\r\n            buffer[i] = _SYMBOLS[value \u0026 0xf];\r\n            value \u003e\u003e= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the two strings are equal.\r\n     */\r\n    function equal(string memory a, string memory b) internal pure returns (bool) {\r\n        return keccak256(bytes(a)) == keccak256(bytes(b));\r\n    }\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../Strings.sol\";\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    enum RecoverError {\r\n        NoError,\r\n        InvalidSignature,\r\n        InvalidSignatureLength,\r\n        InvalidSignatureS,\r\n        InvalidSignatureV // Deprecated in v4.8\r\n    }\r\n\r\n    function _throwError(RecoverError error) private pure {\r\n        if (error == RecoverError.NoError) {\r\n            return; // no error: do nothing\r\n        } else if (error == RecoverError.InvalidSignature) {\r\n            revert(\"ECDSA: invalid signature\");\r\n        } else if (error == RecoverError.InvalidSignatureLength) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        } else if (error == RecoverError.InvalidSignatureS) {\r\n            revert(\"ECDSA: invalid signature \u0027s\u0027 value\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature` or error string. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     *\r\n     * Documentation for signature generation:\r\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\r\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\r\n        if (signature.length == 65) {\r\n            bytes32 r;\r\n            bytes32 s;\r\n            uint8 v;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                s := mload(add(signature, 0x40))\r\n                v := byte(0, mload(add(signature, 0x60)))\r\n            }\r\n            return tryRecover(hash, v, r, s);\r\n        } else {\r\n            return (address(0), RecoverError.InvalidSignatureLength);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\r\n     *\r\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\r\n        bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n        uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\r\n        return tryRecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\r\n     *\r\n     * _Available since v4.2._\r\n     */\r\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return (address(0), RecoverError.InvalidSignatureS);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        if (signer == address(0)) {\r\n            return (address(0), RecoverError.InvalidSignature);\r\n        }\r\n\r\n        return (signer, RecoverError.NoError);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     */\r\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * produces hash corresponding to the one signed with the\r\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n     * JSON-RPC method as part of EIP-191.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\r\n            mstore(0x1c, hash)\r\n            message := keccak256(0x00, 0x3c)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\r\n     * produces hash corresponding to the one signed with the\r\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n     * JSON-RPC method as part of EIP-191.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Typed Data, created from a\r\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\r\n     * to the one signed with the\r\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\r\n     * JSON-RPC method as part of EIP-712.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, \"\\x19\\x01\")\r\n            mstore(add(ptr, 0x02), domainSeparator)\r\n            mstore(add(ptr, 0x22), structHash)\r\n            data := keccak256(ptr, 0x42)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\r\n     * `validator` and `data` according to the version 0 of EIP-191.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\r\n    }\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Tree proofs.\r\n *\r\n * The tree and the proofs can be generated using our\r\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\r\n * You will find a quickstart guide in the readme.\r\n *\r\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\r\n * hashing, or use a hash function other than keccak256 for hashing leaves.\r\n * This is because the concatenation of a sorted pair of internal nodes in\r\n * the merkle tree could be reinterpreted as a leaf value.\r\n * OpenZeppelin\u0027s JavaScript library generates merkle trees that are safe\r\n * against this attack out of the box.\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        return processProof(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {verify}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        return processProofCalldata(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. When processing the proof, the pairs\r\n     * of leafs \u0026 pre-images are assumed to be sorted.\r\n     *\r\n     * _Available since v4.4._\r\n     */\r\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i \u003c proof.length; i++) {\r\n            computedHash = _hashPair(computedHash, proof[i]);\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {processProof}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i \u003c proof.length; i++) {\r\n            computedHash = _hashPair(computedHash, proof[i]);\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\r\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function multiProofVerify(\r\n        bytes32[] memory proof,\r\n        bool[] memory proofFlags,\r\n        bytes32 root,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bool) {\r\n        return processMultiProof(proof, proofFlags, leaves) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {multiProofVerify}\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function multiProofVerifyCalldata(\r\n        bytes32[] calldata proof,\r\n        bool[] calldata proofFlags,\r\n        bytes32 root,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bool) {\r\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\r\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\r\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\r\n     * respectively.\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\r\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\r\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processMultiProof(\r\n        bytes32[] memory proof,\r\n        bool[] memory proofFlags,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bytes32 merkleRoot) {\r\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\r\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\r\n        // the merkle tree.\r\n        uint256 leavesLen = leaves.length;\r\n        uint256 proofLen = proof.length;\r\n        uint256 totalHashes = proofFlags.length;\r\n\r\n        // Check proof validity.\r\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\r\n\r\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\u0027s \"pop\".\r\n        bytes32[] memory hashes = new bytes32[](totalHashes);\r\n        uint256 leafPos = 0;\r\n        uint256 hashPos = 0;\r\n        uint256 proofPos = 0;\r\n        // At each step, we compute the next hash using two values:\r\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n        //   get the next hash.\r\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\r\n        //   `proof` array.\r\n        for (uint256 i = 0; i \u003c totalHashes; i++) {\r\n            bytes32 a = leafPos \u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n            bytes32 b = proofFlags[i]\r\n                ? (leafPos \u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++])\r\n                : proof[proofPos++];\r\n            hashes[i] = _hashPair(a, b);\r\n        }\r\n\r\n        if (totalHashes \u003e 0) {\r\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\r\n            unchecked {\r\n                return hashes[totalHashes - 1];\r\n            }\r\n        } else if (leavesLen \u003e 0) {\r\n            return leaves[0];\r\n        } else {\r\n            return proof[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {processMultiProof}.\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processMultiProofCalldata(\r\n        bytes32[] calldata proof,\r\n        bool[] calldata proofFlags,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bytes32 merkleRoot) {\r\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\r\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\r\n        // the merkle tree.\r\n        uint256 leavesLen = leaves.length;\r\n        uint256 proofLen = proof.length;\r\n        uint256 totalHashes = proofFlags.length;\r\n\r\n        // Check proof validity.\r\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\r\n\r\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\u0027s \"pop\".\r\n        bytes32[] memory hashes = new bytes32[](totalHashes);\r\n        uint256 leafPos = 0;\r\n        uint256 hashPos = 0;\r\n        uint256 proofPos = 0;\r\n        // At each step, we compute the next hash using two values:\r\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n        //   get the next hash.\r\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\r\n        //   `proof` array.\r\n        for (uint256 i = 0; i \u003c totalHashes; i++) {\r\n            bytes32 a = leafPos \u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n            bytes32 b = proofFlags[i]\r\n                ? (leafPos \u003c leavesLen ? leaves[leafPos++] : hashes[hashPos++])\r\n                : proof[proofPos++];\r\n            hashes[i] = _hashPair(a, b);\r\n        }\r\n\r\n        if (totalHashes \u003e 0) {\r\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\r\n            unchecked {\r\n                return hashes[totalHashes - 1];\r\n            }\r\n        } else if (leavesLen \u003e 0) {\r\n            return leaves[0];\r\n        } else {\r\n            return proof[0];\r\n        }\r\n    }\r\n\r\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\r\n        return a \u003c b ? _efficientHash(a, b) : _efficientHash(b, a);\r\n    }\r\n\r\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC165.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/introspection/ERC165Checker.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC165.sol\";\r\n\r\n/**\r\n * @dev Library used to query support of an interface declared via {IERC165}.\r\n *\r\n * Note that these functions return the actual result of the query: they do not\r\n * `revert` if an interface is not supported. It is up to the caller to decide\r\n * what to do in these cases.\r\n */\r\nlibrary ERC165Checker {\r\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\r\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\r\n\r\n    /**\r\n     * @dev Returns true if `account` supports the {IERC165} interface.\r\n     */\r\n    function supportsERC165(address account) internal view returns (bool) {\r\n        // Any contract that implements ERC165 must explicitly indicate support of\r\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\r\n        return\r\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) \u0026\u0026\r\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `account` supports the interface defined by\r\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\r\n        // query support of both ERC165 as per the spec and support of _interfaceId\r\n        return supportsERC165(account) \u0026\u0026 supportsERC165InterfaceUnchecked(account, interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a boolean array where each value corresponds to the\r\n     * interfaces passed in and whether they\u0027re supported or not. This allows\r\n     * you to batch check interfaces for a contract where your expectation\r\n     * is that some interfaces may not be supported.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function getSupportedInterfaces(\r\n        address account,\r\n        bytes4[] memory interfaceIds\r\n    ) internal view returns (bool[] memory) {\r\n        // an array of booleans corresponding to interfaceIds and whether they\u0027re supported or not\r\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\r\n\r\n        // query support of ERC165 itself\r\n        if (supportsERC165(account)) {\r\n            // query support of each interface in interfaceIds\r\n            for (uint256 i = 0; i \u003c interfaceIds.length; i++) {\r\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\r\n            }\r\n        }\r\n\r\n        return interfaceIdsSupported;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `account` supports all the interfaces defined in\r\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\r\n     *\r\n     * Batch-querying can lead to gas savings by skipping repeated checks for\r\n     * {IERC165} support.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\r\n        // query support of ERC165 itself\r\n        if (!supportsERC165(account)) {\r\n            return false;\r\n        }\r\n\r\n        // query support of each interface in interfaceIds\r\n        for (uint256 i = 0; i \u003c interfaceIds.length; i++) {\r\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // all interfaces supported\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Query if a contract implements an interface, does not check ERC165 support\r\n     * @param account The address of the contract to query for support of an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @return true if the contract at account indicates support of the interface with\r\n     * identifier interfaceId, false otherwise\r\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\r\n     * the behavior of this method is undefined. This precondition can be checked\r\n     * with {supportsERC165}.\r\n     *\r\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\r\n     * should be exercised when using this function.\r\n     *\r\n     * Interface identification is specified in ERC-165.\r\n     */\r\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\r\n        // prepare call\r\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\r\n\r\n        // perform static call\r\n        bool success;\r\n        uint256 returnSize;\r\n        uint256 returnValue;\r\n        assembly {\r\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\r\n            returnSize := returndatasize()\r\n            returnValue := mload(0x00)\r\n        }\r\n\r\n        return success \u0026\u0026 returnSize \u003e= 0x20 \u0026\u0026 returnValue \u003e 0;\r\n    }\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a \u003e b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a \u003c b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a \u0026 b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n                // The surrounding unchecked block does not change this fact.\r\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator \u003e prod1, \"Math: mulDiv overflow\");\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always \u003e= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator \u0026 (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\u0027s lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don\u0027t need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.\u0027s \"Hacker\u0027s Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\r\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\r\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton\u0027s method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            result = (result + a / result) \u003e\u003e 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up \u0026\u0026 result * result \u003c a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value \u003e\u003e 128 \u003e 0) {\r\n                value \u003e\u003e= 128;\r\n                result += 128;\r\n            }\r\n            if (value \u003e\u003e 64 \u003e 0) {\r\n                value \u003e\u003e= 64;\r\n                result += 64;\r\n            }\r\n            if (value \u003e\u003e 32 \u003e 0) {\r\n                value \u003e\u003e= 32;\r\n                result += 32;\r\n            }\r\n            if (value \u003e\u003e 16 \u003e 0) {\r\n                value \u003e\u003e= 16;\r\n                result += 16;\r\n            }\r\n            if (value \u003e\u003e 8 \u003e 0) {\r\n                value \u003e\u003e= 8;\r\n                result += 8;\r\n            }\r\n            if (value \u003e\u003e 4 \u003e 0) {\r\n                value \u003e\u003e= 4;\r\n                result += 4;\r\n            }\r\n            if (value \u003e\u003e 2 \u003e 0) {\r\n                value \u003e\u003e= 2;\r\n                result += 2;\r\n            }\r\n            if (value \u003e\u003e 1 \u003e 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value \u003e= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value \u003e= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value \u003e= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value \u003e= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value \u003e= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value \u003e= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value \u003e= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up \u0026\u0026 10 ** result \u003c value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value \u003e\u003e 128 \u003e 0) {\r\n                value \u003e\u003e= 128;\r\n                result += 16;\r\n            }\r\n            if (value \u003e\u003e 64 \u003e 0) {\r\n                value \u003e\u003e= 64;\r\n                result += 8;\r\n            }\r\n            if (value \u003e\u003e 32 \u003e 0) {\r\n                value \u003e\u003e= 32;\r\n                result += 4;\r\n            }\r\n            if (value \u003e\u003e 16 \u003e 0) {\r\n                value \u003e\u003e= 16;\r\n                result += 2;\r\n            }\r\n            if (value \u003e\u003e 8 \u003e 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\r\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s uintXX/intXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and `int256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n    /**\r\n     * @dev Returns the downcasted uint248 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint248).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint248` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 248 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint248(uint256 value) internal pure returns (uint248) {\r\n        require(value \u003c= type(uint248).max, \"SafeCast: value doesn\u0027t fit in 248 bits\");\r\n        return uint248(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint240 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint240).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint240` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 240 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint240(uint256 value) internal pure returns (uint240) {\r\n        require(value \u003c= type(uint240).max, \"SafeCast: value doesn\u0027t fit in 240 bits\");\r\n        return uint240(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint232 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint232).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint232` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 232 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint232(uint256 value) internal pure returns (uint232) {\r\n        require(value \u003c= type(uint232).max, \"SafeCast: value doesn\u0027t fit in 232 bits\");\r\n        return uint232(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint224 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint224).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint224` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 224 bits\r\n     *\r\n     * _Available since v4.2._\r\n     */\r\n    function toUint224(uint256 value) internal pure returns (uint224) {\r\n        require(value \u003c= type(uint224).max, \"SafeCast: value doesn\u0027t fit in 224 bits\");\r\n        return uint224(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint216 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint216).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint216` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 216 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint216(uint256 value) internal pure returns (uint216) {\r\n        require(value \u003c= type(uint216).max, \"SafeCast: value doesn\u0027t fit in 216 bits\");\r\n        return uint216(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint208 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint208).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint208` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 208 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint208(uint256 value) internal pure returns (uint208) {\r\n        require(value \u003c= type(uint208).max, \"SafeCast: value doesn\u0027t fit in 208 bits\");\r\n        return uint208(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint200 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint200).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint200` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 200 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint200(uint256 value) internal pure returns (uint200) {\r\n        require(value \u003c= type(uint200).max, \"SafeCast: value doesn\u0027t fit in 200 bits\");\r\n        return uint200(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint192 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint192).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint192` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 192 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint192(uint256 value) internal pure returns (uint192) {\r\n        require(value \u003c= type(uint192).max, \"SafeCast: value doesn\u0027t fit in 192 bits\");\r\n        return uint192(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint184 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint184).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint184` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 184 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint184(uint256 value) internal pure returns (uint184) {\r\n        require(value \u003c= type(uint184).max, \"SafeCast: value doesn\u0027t fit in 184 bits\");\r\n        return uint184(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint176 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint176).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint176` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 176 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint176(uint256 value) internal pure returns (uint176) {\r\n        require(value \u003c= type(uint176).max, \"SafeCast: value doesn\u0027t fit in 176 bits\");\r\n        return uint176(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint168 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint168).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint168` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 168 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint168(uint256 value) internal pure returns (uint168) {\r\n        require(value \u003c= type(uint168).max, \"SafeCast: value doesn\u0027t fit in 168 bits\");\r\n        return uint168(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint160 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint160).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint160` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 160 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint160(uint256 value) internal pure returns (uint160) {\r\n        require(value \u003c= type(uint160).max, \"SafeCast: value doesn\u0027t fit in 160 bits\");\r\n        return uint160(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint152 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint152).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint152` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 152 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint152(uint256 value) internal pure returns (uint152) {\r\n        require(value \u003c= type(uint152).max, \"SafeCast: value doesn\u0027t fit in 152 bits\");\r\n        return uint152(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint144 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint144).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint144` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 144 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint144(uint256 value) internal pure returns (uint144) {\r\n        require(value \u003c= type(uint144).max, \"SafeCast: value doesn\u0027t fit in 144 bits\");\r\n        return uint144(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint136 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint136).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint136` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 136 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint136(uint256 value) internal pure returns (uint136) {\r\n        require(value \u003c= type(uint136).max, \"SafeCast: value doesn\u0027t fit in 136 bits\");\r\n        return uint136(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value \u003c= type(uint128).max, \"SafeCast: value doesn\u0027t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint120 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint120).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint120` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 120 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint120(uint256 value) internal pure returns (uint120) {\r\n        require(value \u003c= type(uint120).max, \"SafeCast: value doesn\u0027t fit in 120 bits\");\r\n        return uint120(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint112 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint112).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint112` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 112 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint112(uint256 value) internal pure returns (uint112) {\r\n        require(value \u003c= type(uint112).max, \"SafeCast: value doesn\u0027t fit in 112 bits\");\r\n        return uint112(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint104 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint104).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint104` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 104 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint104(uint256 value) internal pure returns (uint104) {\r\n        require(value \u003c= type(uint104).max, \"SafeCast: value doesn\u0027t fit in 104 bits\");\r\n        return uint104(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint96 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint96).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint96` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 96 bits\r\n     *\r\n     * _Available since v4.2._\r\n     */\r\n    function toUint96(uint256 value) internal pure returns (uint96) {\r\n        require(value \u003c= type(uint96).max, \"SafeCast: value doesn\u0027t fit in 96 bits\");\r\n        return uint96(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint88 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint88).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint88` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 88 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint88(uint256 value) internal pure returns (uint88) {\r\n        require(value \u003c= type(uint88).max, \"SafeCast: value doesn\u0027t fit in 88 bits\");\r\n        return uint88(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint80 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint80).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint80` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 80 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint80(uint256 value) internal pure returns (uint80) {\r\n        require(value \u003c= type(uint80).max, \"SafeCast: value doesn\u0027t fit in 80 bits\");\r\n        return uint80(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint72 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint72).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint72` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 72 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint72(uint256 value) internal pure returns (uint72) {\r\n        require(value \u003c= type(uint72).max, \"SafeCast: value doesn\u0027t fit in 72 bits\");\r\n        return uint72(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value \u003c= type(uint64).max, \"SafeCast: value doesn\u0027t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint56 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint56).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint56` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 56 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint56(uint256 value) internal pure returns (uint56) {\r\n        require(value \u003c= type(uint56).max, \"SafeCast: value doesn\u0027t fit in 56 bits\");\r\n        return uint56(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint48 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint48).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint48` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 48 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint48(uint256 value) internal pure returns (uint48) {\r\n        require(value \u003c= type(uint48).max, \"SafeCast: value doesn\u0027t fit in 48 bits\");\r\n        return uint48(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint40 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint40).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint40` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 40 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint40(uint256 value) internal pure returns (uint40) {\r\n        require(value \u003c= type(uint40).max, \"SafeCast: value doesn\u0027t fit in 40 bits\");\r\n        return uint40(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value \u003c= type(uint32).max, \"SafeCast: value doesn\u0027t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint24 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint24).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint24` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 24 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint24(uint256 value) internal pure returns (uint24) {\r\n        require(value \u003c= type(uint24).max, \"SafeCast: value doesn\u0027t fit in 24 bits\");\r\n        return uint24(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value \u003c= type(uint16).max, \"SafeCast: value doesn\u0027t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity\u0027s `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value \u003c= type(uint8).max, \"SafeCast: value doesn\u0027t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     *\r\n     * _Available since v3.0._\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value \u003e= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int248 from int256, reverting on\r\n     * overflow (when the input is less than smallest int248 or\r\n     * greater than largest int248).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int248` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 248 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\r\n        downcasted = int248(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 248 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int240 from int256, reverting on\r\n     * overflow (when the input is less than smallest int240 or\r\n     * greater than largest int240).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int240` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 240 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\r\n        downcasted = int240(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 240 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int232 from int256, reverting on\r\n     * overflow (when the input is less than smallest int232 or\r\n     * greater than largest int232).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int232` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 232 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\r\n        downcasted = int232(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 232 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int224 from int256, reverting on\r\n     * overflow (when the input is less than smallest int224 or\r\n     * greater than largest int224).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int224` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 224 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\r\n        downcasted = int224(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 224 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int216 from int256, reverting on\r\n     * overflow (when the input is less than smallest int216 or\r\n     * greater than largest int216).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int216` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 216 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\r\n        downcasted = int216(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 216 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int208 from int256, reverting on\r\n     * overflow (when the input is less than smallest int208 or\r\n     * greater than largest int208).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int208` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 208 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\r\n        downcasted = int208(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 208 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int200 from int256, reverting on\r\n     * overflow (when the input is less than smallest int200 or\r\n     * greater than largest int200).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int200` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 200 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\r\n        downcasted = int200(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 200 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int192 from int256, reverting on\r\n     * overflow (when the input is less than smallest int192 or\r\n     * greater than largest int192).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int192` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 192 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\r\n        downcasted = int192(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 192 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int184 from int256, reverting on\r\n     * overflow (when the input is less than smallest int184 or\r\n     * greater than largest int184).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int184` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 184 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\r\n        downcasted = int184(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 184 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int176 from int256, reverting on\r\n     * overflow (when the input is less than smallest int176 or\r\n     * greater than largest int176).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int176` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 176 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\r\n        downcasted = int176(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 176 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int168 from int256, reverting on\r\n     * overflow (when the input is less than smallest int168 or\r\n     * greater than largest int168).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int168` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 168 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\r\n        downcasted = int168(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 168 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int160 from int256, reverting on\r\n     * overflow (when the input is less than smallest int160 or\r\n     * greater than largest int160).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int160` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 160 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\r\n        downcasted = int160(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 160 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int152 from int256, reverting on\r\n     * overflow (when the input is less than smallest int152 or\r\n     * greater than largest int152).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int152` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 152 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\r\n        downcasted = int152(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 152 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int144 from int256, reverting on\r\n     * overflow (when the input is less than smallest int144 or\r\n     * greater than largest int144).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int144` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 144 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\r\n        downcasted = int144(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 144 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int136 from int256, reverting on\r\n     * overflow (when the input is less than smallest int136 or\r\n     * greater than largest int136).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int136` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 136 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\r\n        downcasted = int136(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 136 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\r\n        downcasted = int128(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 128 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int120 from int256, reverting on\r\n     * overflow (when the input is less than smallest int120 or\r\n     * greater than largest int120).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int120` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 120 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\r\n        downcasted = int120(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 120 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int112 from int256, reverting on\r\n     * overflow (when the input is less than smallest int112 or\r\n     * greater than largest int112).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int112` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 112 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\r\n        downcasted = int112(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 112 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int104 from int256, reverting on\r\n     * overflow (when the input is less than smallest int104 or\r\n     * greater than largest int104).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int104` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 104 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\r\n        downcasted = int104(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 104 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int96 from int256, reverting on\r\n     * overflow (when the input is less than smallest int96 or\r\n     * greater than largest int96).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int96` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 96 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\r\n        downcasted = int96(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 96 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int88 from int256, reverting on\r\n     * overflow (when the input is less than smallest int88 or\r\n     * greater than largest int88).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int88` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 88 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\r\n        downcasted = int88(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 88 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int80 from int256, reverting on\r\n     * overflow (when the input is less than smallest int80 or\r\n     * greater than largest int80).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int80` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 80 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\r\n        downcasted = int80(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 80 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int72 from int256, reverting on\r\n     * overflow (when the input is less than smallest int72 or\r\n     * greater than largest int72).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int72` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 72 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\r\n        downcasted = int72(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 72 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\r\n        downcasted = int64(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 64 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int56 from int256, reverting on\r\n     * overflow (when the input is less than smallest int56 or\r\n     * greater than largest int56).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int56` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 56 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\r\n        downcasted = int56(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 56 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int48 from int256, reverting on\r\n     * overflow (when the input is less than smallest int48 or\r\n     * greater than largest int48).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int48` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 48 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\r\n        downcasted = int48(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 48 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int40 from int256, reverting on\r\n     * overflow (when the input is less than smallest int40 or\r\n     * greater than largest int40).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int40` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 40 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\r\n        downcasted = int40(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 40 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\r\n        downcasted = int32(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 32 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int24 from int256, reverting on\r\n     * overflow (when the input is less than smallest int24 or\r\n     * greater than largest int24).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int24` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 24 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\r\n        downcasted = int24(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 24 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\r\n        downcasted = int16(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 16 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity\u0027s `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\r\n        downcasted = int8(value);\r\n        require(downcasted == value, \"SafeCast: value doesn\u0027t fit in 8 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     *\r\n     * _Available since v3.0._\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\r\n        require(value \u003c= uint256(type(int256).max), \"SafeCast: value doesn\u0027t fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol": {
            "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Standard signed math utilities missing in the Solidity language.\r\n */\r\nlibrary SignedMath {\r\n    /**\r\n     * @dev Returns the largest of two signed numbers.\r\n     */\r\n    function max(int256 a, int256 b) internal pure returns (int256) {\r\n        return a \u003e b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two signed numbers.\r\n     */\r\n    function min(int256 a, int256 b) internal pure returns (int256) {\r\n        return a \u003c b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two signed numbers without overflow.\r\n     * The result is rounded towards zero.\r\n     */\r\n    function average(int256 a, int256 b) internal pure returns (int256) {\r\n        // Formula from the book \"Hacker\u0027s Delight\"\r\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\r\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the absolute unsigned value of a signed value.\r\n     */\r\n    function abs(int256 n) internal pure returns (uint256) {\r\n        unchecked {\r\n            // must be unchecked in order to support `n = type(int256).min`\r\n            return uint256(n \u003e= 0 ? n : -n);\r\n        }\r\n    }\r\n}\r\n"
        },
        "src/PWNErrors.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\n\r\n/**\r\n * @notice Thrown when an address is missing a PWN Hub tag.\r\n */\r\nerror AddressMissingHubTag(address addr, bytes32 tag);\r\n\r\n/**\r\n * @notice Thrown when a proposal is expired.\r\n */\r\nerror Expired(uint256 current, uint256 expiration);\r\n"
        },
        "src/config/PWNConfig.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport { Ownable2StepUpgradeable } from \"openzeppelin-upgradeable/access/Ownable2StepUpgradeable.sol\";\r\n\r\nimport { IPoolAdapter } from \"pwn/interfaces/IPoolAdapter.sol\";\r\nimport { IStateFingerpringComputer } from \"pwn/interfaces/IStateFingerpringComputer.sol\";\r\n\r\n\r\n/**\r\n * @title PWN Config\r\n * @notice Contract holding configurable values of PWN protocol.\r\n * @dev Is intended to be used as a proxy via `TransparentUpgradeableProxy`.\r\n */\r\ncontract PWNConfig is Ownable2StepUpgradeable {\r\n\r\n    string internal constant VERSION = \"1.3\";\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # VARIABLES \u0026 CONSTANTS DEFINITIONS                     *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    uint16 public constant MAX_FEE = 1000; // 10%\r\n\r\n    /**\r\n     * @notice Protocol fee value in basis points.\r\n     * @dev Value of 100 is 1% fee.\r\n     */\r\n    uint16 public fee;\r\n\r\n    /**\r\n     * @notice Address that collects protocol fees.\r\n     */\r\n    address public feeCollector;\r\n\r\n    /**\r\n     * @notice Mapping of a loan contract address to LOAN token metadata uri.\r\n     * @dev LOAN token minted by a loan contract will return metadata uri stored in this mapping.\r\n     *      If there is no metadata uri for a loan contract, default metadata uri will be used stored under address(0).\r\n     */\r\n    mapping (address =\u003e string) private _loanMetadataUri;\r\n\r\n    /**\r\n     * @notice Mapping holding registered state fingerprint computer to an asset.\r\n     */\r\n    mapping (address =\u003e address) private _sfComputerRegistry;\r\n\r\n    /**\r\n     * @notice Mapping holding registered pool adapter to a pool address.\r\n     */\r\n    mapping (address =\u003e address) private _poolAdapterRegistry;\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # EVENTS DEFINITIONS                                    *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Emitted when new fee value is set.\r\n     */\r\n    event FeeUpdated(uint16 oldFee, uint16 newFee);\r\n\r\n    /**\r\n     * @notice Emitted when new fee collector address is set.\r\n     */\r\n    event FeeCollectorUpdated(address oldFeeCollector, address newFeeCollector);\r\n\r\n    /**\r\n     * @notice Emitted when new LOAN token metadata uri is set.\r\n     */\r\n    event LOANMetadataUriUpdated(address indexed loanContract, string newUri);\r\n\r\n    /**\r\n     * @notice Emitted when new default LOAN token metadata uri is set.\r\n     */\r\n    event DefaultLOANMetadataUriUpdated(string newUri);\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # ERRORS DEFINITIONS                                    *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Thrown when registering a computer which does not support the asset it is registered for.\r\n     */\r\n    error InvalidComputerContract(address computer, address asset);\r\n\r\n    /**\r\n     * @notice Thrown when trying to set a fee value higher than `MAX_FEE`.\r\n     */\r\n    error InvalidFeeValue(uint256 fee, uint256 limit);\r\n\r\n    /**\r\n     * @notice Thrown when trying to set a fee collector to zero address.\r\n     */\r\n    error ZeroFeeCollector();\r\n\r\n    /**\r\n     * @notice Thrown when trying to set a LOAN token metadata uri for zero address loan contract.\r\n     */\r\n    error ZeroLoanContract();\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # CONSTRUCTOR                                           *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    constructor() Ownable2StepUpgradeable() {\r\n        // PWNConfig is used as a proxy. Use initializer to setup initial properties.\r\n        _disableInitializers();\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function initialize(address _owner, uint16 _fee, address _feeCollector) external initializer {\r\n        require(_owner != address(0), \"Owner is zero address\");\r\n        _transferOwnership(_owner);\r\n        _setFeeCollector(_feeCollector);\r\n        _setFee(_fee);\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # FEE MANAGEMENT                                        *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Set new protocol fee value.\r\n     * @param _fee New fee value in basis points. Value of 100 is 1% fee.\r\n     */\r\n    function setFee(uint16 _fee) external onlyOwner {\r\n        _setFee(_fee);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal implementation of setting new protocol fee value.\r\n     * @param _fee New fee value in basis points. Value of 100 is 1% fee.\r\n     */\r\n    function _setFee(uint16 _fee) private {\r\n        if (_fee \u003e MAX_FEE)\r\n            revert InvalidFeeValue({ fee: _fee, limit: MAX_FEE });\r\n\r\n        uint16 oldFee = fee;\r\n        fee = _fee;\r\n        emit FeeUpdated(oldFee, _fee);\r\n    }\r\n\r\n    /**\r\n     * @notice Set new fee collector address.\r\n     * @param _feeCollector New fee collector address.\r\n     */\r\n    function setFeeCollector(address _feeCollector) external onlyOwner {\r\n        _setFeeCollector(_feeCollector);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal implementation of setting new fee collector address.\r\n     * @param _feeCollector New fee collector address.\r\n     */\r\n    function _setFeeCollector(address _feeCollector) private {\r\n        if (_feeCollector == address(0))\r\n            revert ZeroFeeCollector();\r\n\r\n        address oldFeeCollector = feeCollector;\r\n        feeCollector = _feeCollector;\r\n        emit FeeCollectorUpdated(oldFeeCollector, _feeCollector);\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # LOAN METADATA                                         *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Set a LOAN token metadata uri for a specific loan contract.\r\n     * @param loanContract Address of a loan contract.\r\n     * @param metadataUri New value of LOAN token metadata uri for given `loanContract`.\r\n     */\r\n    function setLOANMetadataUri(address loanContract, string memory metadataUri) external onlyOwner {\r\n        if (loanContract == address(0))\r\n            // address(0) is used as a default metadata uri. Use `setDefaultLOANMetadataUri` to set default metadata uri.\r\n            revert ZeroLoanContract();\r\n\r\n        _loanMetadataUri[loanContract] = metadataUri;\r\n        emit LOANMetadataUriUpdated(loanContract, metadataUri);\r\n    }\r\n\r\n    /**\r\n     * @notice Set a default LOAN token metadata uri.\r\n     * @param metadataUri New value of default LOAN token metadata uri.\r\n     */\r\n    function setDefaultLOANMetadataUri(string memory metadataUri) external onlyOwner {\r\n        _loanMetadataUri[address(0)] = metadataUri;\r\n        emit DefaultLOANMetadataUriUpdated(metadataUri);\r\n    }\r\n\r\n    /**\r\n     * @notice Return a LOAN token metadata uri base on a loan contract that minted the token.\r\n     * @param loanContract Address of a loan contract.\r\n     * @return uri Metadata uri for given loan contract.\r\n     */\r\n    function loanMetadataUri(address loanContract) external view returns (string memory uri) {\r\n        uri = _loanMetadataUri[loanContract];\r\n        // If there is no metadata uri for a loan contract, use default metadata uri.\r\n        if (bytes(uri).length == 0)\r\n            uri = _loanMetadataUri[address(0)];\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # STATE FINGERPRINT COMPUTER                            *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Returns the state fingerprint computer for a given asset.\r\n     * @param asset The asset for which the computer is requested.\r\n     * @return The computer for the given asset.\r\n     */\r\n    function getStateFingerprintComputer(address asset) external view returns (IStateFingerpringComputer) {\r\n        return IStateFingerpringComputer(_sfComputerRegistry[asset]);\r\n    }\r\n\r\n    /**\r\n     * @notice Registers a state fingerprint computer for a given asset.\r\n     * @param asset The asset for which the computer is registered.\r\n     * @param computer The computer to be registered. Use address(0) to remove a computer.\r\n     */\r\n    function registerStateFingerprintComputer(address asset, address computer) external onlyOwner {\r\n        if (computer != address(0))\r\n            if (!IStateFingerpringComputer(computer).supportsToken(asset))\r\n                revert InvalidComputerContract({ computer: computer, asset: asset });\r\n\r\n        _sfComputerRegistry[asset] = computer;\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # POOL ADAPTER                                          *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Returns the pool adapter for a given pool.\r\n     * @param pool The pool for which the adapter is requested.\r\n     * @return The adapter for the given pool.\r\n     */\r\n    function getPoolAdapter(address pool) external view returns (IPoolAdapter) {\r\n        return IPoolAdapter(_poolAdapterRegistry[pool]);\r\n    }\r\n\r\n    /**\r\n     * @notice Registers a pool adapter for a given pool.\r\n     * @param pool The pool for which the adapter is registered.\r\n     * @param adapter The adapter to be registered.\r\n     */\r\n    function registerPoolAdapter(address pool, address adapter) external onlyOwner {\r\n        _poolAdapterRegistry[pool] = adapter;\r\n    }\r\n\r\n}\r\n"
        },
        "src/hub/PWNHub.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport { Ownable2Step } from \"openzeppelin/access/Ownable2Step.sol\";\r\n\r\n\r\n/**\r\n * @title PWN Hub\r\n * @notice Connects PWN contracts together into protocol via tags.\r\n */\r\ncontract PWNHub is Ownable2Step {\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # VARIABLES \u0026 CONSTANTS DEFINITIONS                     *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @dev Mapping of address tags. (contract address =\u003e tag =\u003e is tagged)\r\n     */\r\n    mapping (address =\u003e mapping (bytes32 =\u003e bool)) private tags;\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # EVENTS DEFINITIONS                                    *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Emitted when tag is set for an address.\r\n     */\r\n    event TagSet(address indexed _address, bytes32 indexed tag, bool hasTag);\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # ERRORS DEFINITIONS                                    *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Thrown when `PWNHub.setTags` inputs lengths are not equal.\r\n     */\r\n    error InvalidInputData();\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # CONSTRUCTOR                                           *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    constructor() Ownable2Step() {\r\n\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # TAG MANAGEMENT                                        *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Set tag to an address.\r\n     * @dev Tag can be added or removed via this functions. Only callable by contract owner.\r\n     * @param _address Address to which a tag is set.\r\n     * @param tag Tag that is set to an `_address`.\r\n     * @param _hasTag Bool value if tag is added or removed.\r\n     */\r\n    function setTag(address _address, bytes32 tag, bool _hasTag) public onlyOwner {\r\n        tags[_address][tag] = _hasTag;\r\n        emit TagSet(_address, tag, _hasTag);\r\n    }\r\n\r\n    /**\r\n     * @notice Set list of tags to an address.\r\n     * @dev Tags can be added or removed via this functions. Only callable by contract owner.\r\n     * @param _addresses List of addresses to which tags are set.\r\n     * @param _tags List of tags that are set to an `_address`.\r\n     * @param _hasTag Bool value if tags are added or removed.\r\n     */\r\n    function setTags(address[] memory _addresses, bytes32[] memory _tags, bool _hasTag) external onlyOwner {\r\n        if (_addresses.length != _tags.length)\r\n            revert InvalidInputData();\r\n\r\n        uint256 length = _tags.length;\r\n        for (uint256 i; i \u003c length;) {\r\n            setTag(_addresses[i], _tags[i], _hasTag);\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # TAG GETTER                                            *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @dev Return if an address is associated with a tag.\r\n     * @param _address Address that is examined for a `tag`.\r\n     * @param tag Tag that should an `_address` be associated with.\r\n     * @return True if given address has a tag.\r\n     */\r\n    function hasTag(address _address, bytes32 tag) external view returns (bool) {\r\n        return tags[_address][tag];\r\n    }\r\n\r\n}\r\n"
        },
        "src/hub/PWNHubTags.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nlibrary PWNHubTags {\r\n\r\n    string internal constant VERSION = \"1.2\";\r\n\r\n    /// @dev Address can mint LOAN tokens and create LOANs via loan factory contracts.\r\n    bytes32 internal constant ACTIVE_LOAN = keccak256(\"PWN_ACTIVE_LOAN\");\r\n    /// @dev Address can call loan contracts to create and/or refinance a loan.\r\n    bytes32 internal constant LOAN_PROPOSAL = keccak256(\"PWN_LOAN_PROPOSAL\");\r\n    /// @dev Address can revoke nonces on other addresses behalf.\r\n    bytes32 internal constant NONCE_MANAGER = keccak256(\"PWN_NONCE_MANAGER\");\r\n\r\n}\r\n"
        },
        "src/interfaces/IChainlinkAggregatorLike.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\n\r\n/**\r\n * @title IChainlinkAggregatorLike\r\n * @notice Chainlink Aggregator Interface.\r\n */\r\ninterface IChainlinkAggregatorLike {\r\n\r\n    /**\r\n     * @notice Get the number of decimals for the aggregator answers.\r\n     * @return Number of decimals.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @notice Get the description of the aggregator.\r\n     * @return Description of the aggregator.\r\n     */\r\n    function description() external view returns (string memory);\r\n\r\n    /**\r\n     * @notice Get the latest round data for the aggregator.\r\n     * @return roundId The round ID from the aggregator for which the data was retrieved combined with a phase to ensure that round IDs get larger as time moves forward.\r\n     * @return answer The answer for the latest round.\r\n     * @return startedAt The timestamp when the round was started. (Only some AggregatorV3Interface implementations return meaningful values).\r\n     * @return updatedAt The timestamp when the round last was updated (i.e. answer was last computed).\r\n     * @return answeredInRound The round ID of the round in which the answer was computed. (Only some AggregatorV3Interface implementations return meaningful values).\r\n     */\r\n    function latestRoundData() external view returns (\r\n        uint80 roundId,\r\n        int256 answer,\r\n        uint256 startedAt,\r\n        uint256 updatedAt,\r\n        uint80 answeredInRound\r\n    );\r\n\r\n}\r\n"
        },
        "src/interfaces/IChainlinkFeedRegistryLike.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport { IChainlinkAggregatorLike } from \"pwn/interfaces/IChainlinkAggregatorLike.sol\";\r\n\r\n\r\n/**\r\n * @title IChainlinkFeedRegistryLike\r\n * @notice Chainlink Feed Registry Interface.\r\n */\r\ninterface IChainlinkFeedRegistryLike {\r\n\r\n    /**\r\n     * @notice Get the Chainlink aggregator for a given base and quote asset.\r\n     * @param base Base asset address.\r\n     * @param quote Quote asset address.\r\n     * @return aggregator Chainlink aggregator for the given base and quote asset.\r\n     */\r\n    function getFeed(address base, address quote) external view returns (IChainlinkAggregatorLike aggregator);\r\n\r\n    /**\r\n     * @notice Allows an owner to begin transferring ownership to a new address,\r\n     * pending.\r\n     */\r\n    function transferOwnership(address to) external;\r\n\r\n    /**\r\n     * @notice Allows an ownership transfer to be completed by the recipient.\r\n     */\r\n    function acceptOwnership() external;\r\n\r\n    /**\r\n     * @notice Propose a new Chainlink aggregator for a given base and quote asset.\r\n     * @param base Base asset address.\r\n     * @param quote Quote asset address.\r\n     * @param aggregator Chainlink aggregator address.\r\n     */\r\n    function proposeFeed(address base, address quote, address aggregator) external;\r\n\r\n    /**\r\n     * @notice Confirm a new Chainlink aggregator for a given base and quote asset.\r\n     * @param base Base asset address.\r\n     * @param quote Quote asset address.\r\n     * @param aggregator Chainlink aggregator address.\r\n     */\r\n    function confirmFeed(address base, address quote, address aggregator) external;\r\n\r\n}\r\n"
        },
        "src/interfaces/IERC5646.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\n/**\r\n * @title IERC5646\r\n * @notice Interface of the ERC5646 standard, as defined in the https://eips.ethereum.org/EIPS/eip-5646.\r\n */\r\ninterface IERC5646 {\r\n\r\n    /**\r\n     * @notice Function to return current token state fingerprint.\r\n     * @param tokenId Id of a token state in question.\r\n     * @return Current token state fingerprint.\r\n     */\r\n    function getStateFingerprint(uint256 tokenId) external view returns (bytes32);\r\n\r\n}\r\n"
        },
        "src/interfaces/IPWNLoanMetadataProvider.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\n/**\r\n * @title IPWNLoanMetadataProvider\r\n * @notice Interface for a provider of a LOAN token metadata.\r\n * @dev Loan contracts should implement this interface.\r\n */\r\ninterface IPWNLoanMetadataProvider {\r\n\r\n    /**\r\n     * @notice Get a loan metadata uri for a LOAN token minted by this contract.\r\n     * @return LOAN token metadata uri.\r\n     */\r\n    function loanMetadataUri() external view returns (string memory);\r\n\r\n}\r\n"
        },
        "src/interfaces/IPoolAdapter.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\n/**\r\n * @title IPoolAdapter\r\n * @notice Interface for pool adapters used to withdraw and supply assets to the pool.\r\n */\r\ninterface IPoolAdapter {\r\n\r\n    /**\r\n     * @notice Withdraw an asset from the pool on behalf of the owner.\r\n     * @dev Withdrawn asset remains in the owner. Caller must have the ACTIVE_LOAN tag in the hub.\r\n     * @param pool The address of the pool from which the asset is withdrawn.\r\n     * @param owner The address of the owner from whom the asset is withdrawn.\r\n     * @param asset The address of the asset to withdraw.\r\n     * @param amount The amount of the asset to withdraw.\r\n     */\r\n    function withdraw(address pool, address owner, address asset, uint256 amount) external;\r\n\r\n    /**\r\n     * @notice Supply an asset to the pool on behalf of the owner.\r\n     * @dev Need to transfer the asset to the adapter before calling this function.\r\n     * @param pool The address of the pool to which the asset is supplied.\r\n     * @param owner The address of the owner on whose behalf the asset is supplied.\r\n     * @param asset The address of the asset to supply.\r\n     * @param amount The amount of the asset to supply.\r\n     */\r\n    function supply(address pool, address owner, address asset, uint256 amount) external;\r\n\r\n}\r\n"
        },
        "src/interfaces/IStateFingerpringComputer.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\n/**\r\n * @title IStateFingerpringComputer\r\n * @notice State Fingerprint Computer Interface.\r\n * @dev Contract can compute state fingerprint of several tokens as long as they share the same state structure.\r\n */\r\ninterface IStateFingerpringComputer {\r\n\r\n    /**\r\n     * @notice Compute current token state fingerprint for a given token.\r\n     * @param token Address of a token contract.\r\n     * @param tokenId Token id to compute state fingerprint for.\r\n     * @return Current token state fingerprint.\r\n     */\r\n    function computeStateFingerprint(address token, uint256 tokenId) external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Check if the computer supports a given token address.\r\n     * @param token Address of a token contract.\r\n     * @return True if the computer supports the token address, false otherwise.\r\n     */\r\n    function supportsToken(address token) external view returns (bool);\r\n\r\n}\r\n"
        },
        "src/loan/lib/Chainlink.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport { Math } from \"openzeppelin/utils/math/Math.sol\";\r\n\r\nimport { IChainlinkAggregatorLike } from \"pwn/interfaces/IChainlinkAggregatorLike.sol\";\r\nimport { IChainlinkFeedRegistryLike } from \"pwn/interfaces/IChainlinkFeedRegistryLike.sol\";\r\n\r\n\r\nlibrary Chainlink {\r\n\r\n    /**\r\n     * @notice Maximum Chainlink feed price age.\r\n     */\r\n    uint256 public constant MAX_CHAINLINK_FEED_PRICE_AGE = 1 days;\r\n\r\n    /**\r\n     * @notice Grace period time for L2 Sequencer uptime feed.\r\n     */\r\n    uint256 public constant L2_GRACE_PERIOD = 10 minutes;\r\n\r\n    /**\r\n     * @notice Chainlink address of ETH asset.\r\n     */\r\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    /**\r\n     * @notice Throw when Chainlink feed returns negative price.\r\n     */\r\n    error ChainlinkFeedReturnedNegativePrice(address feed, int256 price, uint256 updatedAt);\r\n\r\n    /**\r\n     * @notice Throw when Chainlink feed price is too old.\r\n     */\r\n    error ChainlinkFeedPriceTooOld(address feed, uint256 updatedAt);\r\n\r\n    /**\r\n     * @notice Throw when feed invert array is not exactly one item longer than intermediary feed array.\r\n     */\r\n    error ChainlinkInvalidInputLenghts();\r\n\r\n    /**\r\n     * @notice Throw when L2 Sequencer uptime feed returns that the sequencer is down.\r\n     */\r\n    error L2SequencerDown();\r\n\r\n    /**\r\n     * @notice Throw when L2 Sequencer uptime feed grace period is not over.\r\n     */\r\n    error GracePeriodNotOver(uint256 timeSinceUp, uint256 gracePeriod);\r\n\r\n\r\n    /**\r\n     * @notice Checks the uptime status of the L2 sequencer.\r\n     * @dev This function reverts if the sequencer is down or if the grace period is not over.\r\n     * @param l2SequencerUptimeFeed The Chainlink feed that provides the sequencer uptime status.\r\n     */\r\n    function checkSequencerUptime(IChainlinkAggregatorLike l2SequencerUptimeFeed) internal view {\r\n        if (address(l2SequencerUptimeFeed) != address(0)) {\r\n            (, int256 answer, uint256 startedAt,,) = l2SequencerUptimeFeed.latestRoundData();\r\n            if (answer == 1) {\r\n                // sequencer is down\r\n                revert L2SequencerDown();\r\n            }\r\n\r\n            uint256 timeSinceUp = block.timestamp - startedAt;\r\n            if (timeSinceUp \u003c= L2_GRACE_PERIOD) {\r\n                // grace period is not over\r\n                revert GracePeriodNotOver({ timeSinceUp: timeSinceUp, gracePeriod: L2_GRACE_PERIOD });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Fetches the prices of the credit with collateral assets as denomination.\r\n     * @dev `feedInvertFlags` array must be exactly one item longer than `feedIntermediaryDenominations`.\r\n     * @param feedRegistry The Chainlink feed registry contract that provides the price feeds.\r\n     * @param creditAsset The address of the credit asset.\r\n     * @param collateralAsset The address of the collateral asset.\r\n     * @param feedIntermediaryDenominations List of intermediary price feeds that will be fetched to get to the collateral asset denominator.\r\n     * @param feedInvertFlags List of flags indicating if price feeds exist only for inverted base and quote assets.\r\n     * @return The price of the credit assets denominated in collateral assets.\r\n     * @return The price decimals.\r\n     */\r\n    function fetchCreditPriceWithCollateralDenomination(\r\n        IChainlinkFeedRegistryLike feedRegistry,\r\n        address creditAsset,\r\n        address collateralAsset,\r\n        address[] memory feedIntermediaryDenominations,\r\n        bool[] memory feedInvertFlags\r\n    ) internal view returns (uint256, uint8) {\r\n        if (feedInvertFlags.length != feedIntermediaryDenominations.length + 1) {\r\n            revert ChainlinkInvalidInputLenghts();\r\n        }\r\n\r\n        // initial state\r\n        uint256 price = 1;\r\n        uint8 priceDecimals = 0;\r\n\r\n        // iterate until collateral asset is denominator\r\n        for (uint256 i; i \u003c feedInvertFlags.length; ++i) {\r\n            (price, priceDecimals) = convertPriceDenomination({\r\n                feedRegistry: feedRegistry,\r\n                currentPrice: price,\r\n                currentDecimals: priceDecimals,\r\n                currentDenomination: i == 0 ? creditAsset : feedIntermediaryDenominations[i - 1],\r\n                nextDenomination: i == feedIntermediaryDenominations.length ? collateralAsset : feedIntermediaryDenominations[i],\r\n                nextInvert: feedInvertFlags[i]\r\n            });\r\n        }\r\n\r\n        return (price, priceDecimals);\r\n    }\r\n\r\n    /**\r\n     * @notice Convert price denomination.\r\n     * @param feedRegistry The Chainlink feed registry contract that provides the price feeds.\r\n     * @param currentPrice Price of an asset denominated in `currentDenomination`.\r\n     * @param currentDecimals Decimals of the current price.\r\n     * @param currentDenomination Address of the current denomination.\r\n     * @param nextDenomination Address of the denomination to convert the current price to.\r\n     * @param nextInvert Flag, if intermediary price feed exists only with inverted base and quote assets.\r\n     * @return nextPrice Price of an asset denomination in `nextDenomination`.\r\n     * @return nextDecimals Decimals of the next price.\r\n     */\r\n    function convertPriceDenomination(\r\n        IChainlinkFeedRegistryLike feedRegistry,\r\n        uint256 currentPrice,\r\n        uint8 currentDecimals,\r\n        address currentDenomination,\r\n        address nextDenomination,\r\n        bool nextInvert\r\n    ) internal view returns (uint256 nextPrice, uint8 nextDecimals) {\r\n        // fetch convert price\r\n        (uint256 intermediaryPrice, uint8 intermediaryDecimals) = fetchPrice({\r\n            feedRegistry: feedRegistry,\r\n            asset: nextInvert ? nextDenomination : currentDenomination,\r\n            denomination: nextInvert ? currentDenomination : nextDenomination\r\n        });\r\n\r\n        // sync decimals\r\n        (currentPrice, intermediaryPrice, nextDecimals)\r\n            = syncDecimalsUp(currentPrice, currentDecimals, intermediaryPrice, intermediaryDecimals);\r\n\r\n        // compute price with new denomination\r\n        if (nextInvert) {\r\n            nextPrice = Math.mulDiv(currentPrice, 10 ** nextDecimals, intermediaryPrice);\r\n        } else {\r\n            nextPrice = Math.mulDiv(currentPrice, intermediaryPrice, 10 ** nextDecimals);\r\n        }\r\n\r\n        return (nextPrice, nextDecimals);\r\n    }\r\n\r\n    /**\r\n     * @notice Fetch price from Chainlink feed.\r\n     * @param feedRegistry The Chainlink feed registry contract that provides the price feeds.\r\n     * @param asset Address of an asset.\r\n     * @param denomination Address of a denomination asset.\r\n     * @return price Price of an asset.\r\n     * @return decimals Decimals of a price.\r\n     */\r\n    function fetchPrice(IChainlinkFeedRegistryLike feedRegistry, address asset, address denomination)\r\n        internal\r\n        view\r\n        returns (uint256, uint8)\r\n    {\r\n        IChainlinkAggregatorLike feed = feedRegistry.getFeed(asset, denomination);\r\n\r\n        // Note: registry reverts with \"Feed not found\" for no registered feed\r\n\r\n        (, int256 price,, uint256 updatedAt,) = feed.latestRoundData();\r\n        if (price \u003c 0) {\r\n            revert ChainlinkFeedReturnedNegativePrice({ feed: address(feed), price: price, updatedAt: updatedAt });\r\n        }\r\n        if (block.timestamp - updatedAt \u003e MAX_CHAINLINK_FEED_PRICE_AGE) {\r\n            revert ChainlinkFeedPriceTooOld({ feed: address(feed), updatedAt: updatedAt });\r\n        }\r\n\r\n        return (uint256(price), feed.decimals());\r\n    }\r\n\r\n    /**\r\n     * @notice Sync price decimals to the higher one.\r\n     * @param price1 Price one to be scaled.\r\n     * @param decimals1 Decimals of the price one.\r\n     * @param price2 Price two to be scaled.\r\n     * @param decimals2 Decimals of the price two.\r\n     * @return Synced price one.\r\n     * @return Synced price two.\r\n     * @return Synced price decimals.\r\n     */\r\n    function syncDecimalsUp(uint256 price1, uint8 decimals1, uint256 price2, uint8 decimals2)\r\n        internal\r\n        pure\r\n        returns (uint256, uint256, uint8)\r\n    {\r\n        uint8 syncedDecimals;\r\n        if (decimals1 \u003e decimals2) {\r\n            syncedDecimals = decimals1;\r\n            price2 *= 10 ** (decimals1 - decimals2);\r\n        } else {\r\n            syncedDecimals = decimals2;\r\n            price1 *= 10 ** (decimals2 - decimals1);\r\n        }\r\n\r\n        return (price1, price2, syncedDecimals);\r\n    }\r\n\r\n}\r\n"
        },
        "src/loan/lib/PWNFeeCalculator.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport { Math } from \"openzeppelin/utils/math/Math.sol\";\r\n\r\n\r\n/**\r\n * @title PWN Fee Calculator\r\n * @notice Library that calculates fee amount for given loan amount.\r\n */\r\nlibrary PWNFeeCalculator {\r\n\r\n    string internal constant VERSION = \"1.1\";\r\n\r\n    /**\r\n     * @notice Compute fee amount.\r\n     * @param fee Fee value in basis points. Value of 100 is 1% fee.\r\n     * @param loanAmount Amount of an asset used as a loan credit.\r\n     * @return feeAmount Amount of a loan asset that represents a protocol fee.\r\n     * @return newLoanAmount New amount of a loan credit asset, after deducting protocol fee.\r\n     */\r\n    function calculateFeeAmount(uint16 fee, uint256 loanAmount) internal pure returns (uint256 feeAmount, uint256 newLoanAmount) {\r\n        if (fee == 0)\r\n            return (0, loanAmount);\r\n\r\n        feeAmount = Math.mulDiv(loanAmount, fee, 1e4);\r\n        newLoanAmount = loanAmount - feeAmount;\r\n    }\r\n\r\n}\r\n"
        },
        "src/loan/lib/PWNSignatureChecker.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport { ECDSA } from \"openzeppelin/utils/cryptography/ECDSA.sol\";\r\nimport { IERC1271 } from \"openzeppelin/interfaces/IERC1271.sol\";\r\n\r\n\r\n/**\r\n * @title PWN Signature Checker\r\n * @notice Library to check if a given signature is valid for EOAs or contract accounts.\r\n * @dev This library is a modification of an Open-Zeppelin `SignatureChecker` library extended by a support for EIP-2098 compact signatures.\r\n */\r\nlibrary PWNSignatureChecker {\r\n\r\n    string internal constant VERSION = \"1.0\";\r\n\r\n    /**\r\n     * @dev Thrown when signature length is not 64 nor 65 bytes.\r\n     */\r\n    error InvalidSignatureLength(uint256 length);\r\n\r\n    /**\r\n     * @dev Thrown when signature is invalid.\r\n     */\r\n    error InvalidSignature(address signer, bytes32 digest);\r\n\r\n    /**\r\n     * @dev Function will try to recover a signer of a given signature and check if is the same as given signer address.\r\n     *      For a contract account signer address, function will check signature validity by calling `isValidSignature` function defined by EIP-1271.\r\n     * @param signer Address that should be a `hash` signer or a signature validator, in case of a contract account.\r\n     * @param hash Hash of a signed message that should validated.\r\n     * @param signature Signature of a signed `hash`. Could be empty for a contract account signature validation.\r\n     *                  Signature can be standard (65 bytes) or compact (64 bytes) defined by EIP-2098.\r\n     * @return True if a signature is valid.\r\n     */\r\n    function isValidSignatureNow(\r\n        address signer,\r\n        bytes32 hash,\r\n        bytes memory signature\r\n    ) internal view returns (bool) {\r\n        // Check that signature is valid for contract account\r\n        if (signer.code.length \u003e 0) {\r\n            (bool success, bytes memory result) = signer.staticcall(\r\n                abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\r\n            );\r\n            return\r\n                success \u0026\u0026\r\n                result.length == 32 \u0026\u0026\r\n                abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector);\r\n        }\r\n        // Check that signature is valid for EOA\r\n        else {\r\n            bytes32 r;\r\n            bytes32 s;\r\n            uint8 v;\r\n\r\n            // Standard signature data (65 bytes)\r\n            if (signature.length == 65) {\r\n                assembly {\r\n                    r := mload(add(signature, 0x20))\r\n                    s := mload(add(signature, 0x40))\r\n                    v := byte(0, mload(add(signature, 0x60)))\r\n                }\r\n            }\r\n            // Compact signature data (64 bytes) - see EIP-2098\r\n            else if (signature.length == 64) {\r\n                bytes32 vs;\r\n\r\n                assembly {\r\n                    r := mload(add(signature, 0x20))\r\n                    vs := mload(add(signature, 0x40))\r\n                }\r\n\r\n                s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n                v = uint8((uint256(vs) \u003e\u003e 255) + 27);\r\n            } else {\r\n                revert InvalidSignatureLength({ length: signature.length });\r\n            }\r\n\r\n            return signer == ECDSA.recover(hash, v, r, s);\r\n        }\r\n    }\r\n\r\n}\r\n"
        },
        "src/loan/terms/simple/loan/PWNSimpleLoan.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport { MultiToken, IMultiTokenCategoryRegistry } from \"MultiToken/MultiToken.sol\";\r\n\r\nimport { ReentrancyGuard } from \"openzeppelin/security/ReentrancyGuard.sol\";\r\nimport { Math } from \"openzeppelin/utils/math/Math.sol\";\r\nimport { SafeCast } from \"openzeppelin/utils/math/SafeCast.sol\";\r\n\r\nimport { PWNConfig } from \"pwn/config/PWNConfig.sol\";\r\nimport { PWNHub } from \"pwn/hub/PWNHub.sol\";\r\nimport { PWNHubTags } from \"pwn/hub/PWNHubTags.sol\";\r\nimport { IERC5646 } from \"pwn/interfaces/IERC5646.sol\";\r\nimport { IPoolAdapter } from \"pwn/interfaces/IPoolAdapter.sol\";\r\nimport { IPWNLoanMetadataProvider } from \"pwn/interfaces/IPWNLoanMetadataProvider.sol\";\r\nimport { PWNFeeCalculator } from \"pwn/loan/lib/PWNFeeCalculator.sol\";\r\nimport { PWNSignatureChecker } from \"pwn/loan/lib/PWNSignatureChecker.sol\";\r\nimport { PWNSimpleLoanProposal } from \"pwn/loan/terms/simple/proposal/PWNSimpleLoanProposal.sol\";\r\nimport { PWNLOAN } from \"pwn/loan/token/PWNLOAN.sol\";\r\nimport { PWNVault } from \"pwn/loan/vault/PWNVault.sol\";\r\nimport { PWNRevokedNonce } from \"pwn/nonce/PWNRevokedNonce.sol\";\r\nimport { Expired, AddressMissingHubTag } from \"pwn/PWNErrors.sol\";\r\n\r\n\r\n/**\r\n * @title PWN Simple Loan\r\n * @notice Contract managing a simple loan in PWN protocol.\r\n * @dev Acts as a vault for every loan created by this contract.\r\n */\r\ncontract PWNSimpleLoan is PWNVault, ReentrancyGuard, IERC5646, IPWNLoanMetadataProvider {\r\n    using MultiToken for address;\r\n\r\n    string public constant VERSION = \"1.3\";\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # VARIABLES \u0026 CONSTANTS DEFINITIONS                     *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    uint32 public constant MIN_LOAN_DURATION = 10 minutes;\r\n    uint40 public constant MAX_ACCRUING_INTEREST_APR = 16e6; // 160,000 APR (with 2 decimals)\r\n\r\n    uint256 public constant ACCRUING_INTEREST_APR_DECIMALS = 1e2;\r\n    uint256 public constant MINUTES_IN_YEAR = 525_600; // Note: Assuming 365 days in a year\r\n    uint256 public constant ACCRUING_INTEREST_APR_DENOMINATOR = ACCRUING_INTEREST_APR_DECIMALS * MINUTES_IN_YEAR * 100;\r\n\r\n    uint256 public constant MAX_EXTENSION_DURATION = 90 days;\r\n    uint256 public constant MIN_EXTENSION_DURATION = 1 days;\r\n\r\n    bytes32 public constant EXTENSION_PROPOSAL_TYPEHASH = keccak256(\r\n        \"ExtensionProposal(uint256 loanId,address compensationAddress,uint256 compensationAmount,uint40 duration,uint40 expiration,address proposer,uint256 nonceSpace,uint256 nonce)\"\r\n    );\r\n\r\n    bytes32 public immutable DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n        keccak256(\"PWNSimpleLoan\"),\r\n        keccak256(abi.encodePacked(VERSION)),\r\n        block.chainid,\r\n        address(this)\r\n    ));\r\n\r\n    PWNHub public immutable hub;\r\n    PWNLOAN public immutable loanToken;\r\n    PWNConfig public immutable config;\r\n    PWNRevokedNonce public immutable revokedNonce;\r\n    IMultiTokenCategoryRegistry public immutable categoryRegistry;\r\n\r\n    /**\r\n     * @notice Struct defining a simple loan terms.\r\n     * @dev This struct is created by proposal contracts and never stored.\r\n     * @param lender Address of a lender.\r\n     * @param borrower Address of a borrower.\r\n     * @param duration Loan duration in seconds.\r\n     * @param collateral Asset used as a loan collateral. For a definition see { MultiToken dependency lib }.\r\n     * @param credit Asset used as a loan credit. For a definition see { MultiToken dependency lib }.\r\n     * @param fixedInterestAmount Fixed interest amount in credit asset tokens. It is the minimum amount of interest which has to be paid by a borrower.\r\n     * @param accruingInterestAPR Accruing interest APR with 2 decimals.\r\n     * @param lenderSpecHash Hash of a lender specification.\r\n     * @param borrowerSpecHash Hash of a borrower specification.\r\n     */\r\n    struct Terms {\r\n        address lender;\r\n        address borrower;\r\n        uint32 duration;\r\n        MultiToken.Asset collateral;\r\n        MultiToken.Asset credit;\r\n        uint256 fixedInterestAmount;\r\n        uint24 accruingInterestAPR;\r\n        bytes32 lenderSpecHash;\r\n        bytes32 borrowerSpecHash;\r\n    }\r\n\r\n    /**\r\n     * @notice Loan proposal specification during loan creation.\r\n     * @param proposalContract Address of a loan proposal contract.\r\n     * @param proposalData Encoded proposal data that is passed to the loan proposal contract.\r\n     * @param proposalInclusionProof Inclusion proof of the proposal in the proposal contract.\r\n     * @param signature Signature of the proposal.\r\n     */\r\n    struct ProposalSpec {\r\n        address proposalContract;\r\n        bytes proposalData;\r\n        bytes32[] proposalInclusionProof;\r\n        bytes signature;\r\n    }\r\n\r\n    /**\r\n     * @notice Lender specification during loan creation.\r\n     * @param sourceOfFunds Address of a source of funds. This can be the lenders address, if the loan is funded directly,\r\n     *                      or a pool address from with the funds are withdrawn on the lenders behalf.\r\n     */\r\n    struct LenderSpec {\r\n        address sourceOfFunds;\r\n    }\r\n\r\n    /**\r\n     * @notice Caller specification during loan creation.\r\n     * @param refinancingLoanId Id of a loan to be refinanced. 0 if creating a new loan.\r\n     * @param revokeNonce Flag if the callers nonce should be revoked.\r\n     * @param nonce Callers nonce to be revoked. Nonce is revoked from the current nonce space.\r\n     */\r\n    struct CallerSpec {\r\n        uint256 refinancingLoanId;\r\n        bool revokeNonce;\r\n        uint256 nonce;\r\n    }\r\n\r\n    /**\r\n     * @notice Struct defining a simple loan.\r\n     * @param status 0 == none/dead || 2 == running/accepted offer/accepted request || 3 == paid back || 4 == expired.\r\n     * @param creditAddress Address of an asset used as a loan credit.\r\n     * @param originalSourceOfFunds Address of a source of funds that was used to fund the loan.\r\n     * @param startTimestamp Unix timestamp (in seconds) of a start date.\r\n     * @param defaultTimestamp Unix timestamp (in seconds) of a default date.\r\n     * @param borrower Address of a borrower.\r\n     * @param originalLender Address of a lender that funded the loan.\r\n     * @param accruingInterestAPR Accruing interest APR with 2 decimals.\r\n     * @param fixedInterestAmount Fixed interest amount in credit asset tokens.\r\n     *                            It is the minimum amount of interest which has to be paid by a borrower.\r\n     *                            This property is reused to store the final interest amount if the loan is repaid and waiting to be claimed.\r\n     * @param principalAmount Principal amount in credit asset tokens.\r\n     * @param collateral Asset used as a loan collateral. For a definition see { MultiToken dependency lib }.\r\n     */\r\n    struct LOAN {\r\n        uint8 status;\r\n        address creditAddress;\r\n        address originalSourceOfFunds;\r\n        uint40 startTimestamp;\r\n        uint40 defaultTimestamp;\r\n        address borrower;\r\n        address originalLender;\r\n        uint24 accruingInterestAPR;\r\n        uint256 fixedInterestAmount;\r\n        uint256 principalAmount;\r\n        MultiToken.Asset collateral;\r\n    }\r\n\r\n    /**\r\n     * Mapping of all LOAN data by loan id.\r\n     */\r\n    mapping (uint256 =\u003e LOAN) private LOANs;\r\n\r\n    /**\r\n     * @notice Struct defining a loan extension proposal that can be signed by a borrower or a lender.\r\n     * @param loanId Id of a loan to be extended.\r\n     * @param compensationAddress Address of a compensation asset.\r\n     * @param compensationAmount Amount of a compensation asset that a borrower has to pay to a lender.\r\n     * @param duration Duration of the extension in seconds.\r\n     * @param expiration Unix timestamp (in seconds) of an expiration date.\r\n     * @param proposer Address of a proposer that signed the extension proposal.\r\n     * @param nonceSpace Nonce space of the extension proposal nonce.\r\n     * @param nonce Nonce of the extension proposal.\r\n     */\r\n    struct ExtensionProposal {\r\n        uint256 loanId;\r\n        address compensationAddress;\r\n        uint256 compensationAmount;\r\n        uint40 duration;\r\n        uint40 expiration;\r\n        address proposer;\r\n        uint256 nonceSpace;\r\n        uint256 nonce;\r\n    }\r\n\r\n    /**\r\n     * Mapping of extension proposals made via on-chain transaction by extension hash.\r\n     */\r\n    mapping (bytes32 =\u003e bool) public extensionProposalsMade;\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # EVENTS DEFINITIONS                                    *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Emitted when a new loan in created.\r\n     */\r\n    event LOANCreated(uint256 indexed loanId, bytes32 indexed proposalHash, address indexed proposalContract, uint256 refinancingLoanId, Terms terms, LenderSpec lenderSpec, bytes extra);\r\n\r\n    /**\r\n     * @notice Emitted when a loan is paid back.\r\n     */\r\n    event LOANPaidBack(uint256 indexed loanId);\r\n\r\n    /**\r\n     * @notice Emitted when a repaid or defaulted loan is claimed.\r\n     */\r\n    event LOANClaimed(uint256 indexed loanId, bool indexed defaulted);\r\n\r\n    /**\r\n     * @notice Emitted when a LOAN token holder extends a loan.\r\n     */\r\n    event LOANExtended(uint256 indexed loanId, uint40 originalDefaultTimestamp, uint40 extendedDefaultTimestamp);\r\n\r\n    /**\r\n     * @notice Emitted when a loan extension proposal is made.\r\n     */\r\n    event ExtensionProposalMade(bytes32 indexed extensionHash, address indexed proposer,  ExtensionProposal proposal);\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # ERRORS DEFINITIONS                                    *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Thrown when managed loan is running.\r\n     */\r\n    error LoanNotRunning();\r\n\r\n    /**\r\n     * @notice Thrown when manged loan is still running.\r\n     */\r\n    error LoanRunning();\r\n\r\n    /**\r\n     * @notice Thrown when managed loan is repaid.\r\n     */\r\n    error LoanRepaid();\r\n\r\n    /**\r\n     * @notice Thrown when managed loan is not repaid.\r\n     */\r\n    error LoanNotRepaid();\r\n\r\n    /**\r\n     * @notice Thrown when managed loan is defaulted.\r\n     */\r\n    error LoanDefaulted(uint40 timestap);\r\n\r\n    /**\r\n     * @notice Thrown when loan doesn\u0027t exist.\r\n     */\r\n    error NonExistingLoan();\r\n\r\n    /**\r\n     * @notice Thrown when caller is not a LOAN token holder.\r\n     */\r\n    error CallerNotLOANTokenHolder();\r\n\r\n    /**\r\n     * @notice Thrown when refinancing loan terms have different borrower than the original loan.\r\n     */\r\n    error RefinanceBorrowerMismatch(address currentBorrower, address newBorrower);\r\n\r\n    /**\r\n     * @notice Thrown when refinancing loan terms have different credit asset than the original loan.\r\n     */\r\n    error RefinanceCreditMismatch();\r\n\r\n    /**\r\n     * @notice Thrown when refinancing loan terms have different collateral asset than the original loan.\r\n     */\r\n    error RefinanceCollateralMismatch();\r\n\r\n    /**\r\n     * @notice Thrown when hash of provided lender spec doesn\u0027t match the one in loan terms.\r\n     */\r\n    error InvalidLenderSpecHash(bytes32 current, bytes32 expected);\r\n\r\n    /**\r\n     * @notice Thrown when loan duration is below the minimum.\r\n     */\r\n    error InvalidDuration(uint256 current, uint256 limit);\r\n\r\n    /**\r\n     * @notice Thrown when accruing interest APR is above the maximum.\r\n     */\r\n    error InterestAPROutOfBounds(uint256 current, uint256 limit);\r\n\r\n    /**\r\n     * @notice Thrown when caller is not a vault.\r\n     */\r\n    error CallerNotVault();\r\n\r\n    /**\r\n     * @notice Thrown when pool based source of funds doesn\u0027t have a registered adapter.\r\n     */\r\n    error InvalidSourceOfFunds(address sourceOfFunds);\r\n\r\n    /**\r\n     * @notice Thrown when caller is not a loan borrower or lender.\r\n     */\r\n    error InvalidExtensionCaller();\r\n\r\n    /**\r\n     * @notice Thrown when signer is not a loan extension proposer.\r\n     */\r\n    error InvalidExtensionSigner(address allowed, address current);\r\n\r\n    /**\r\n     * @notice Thrown when loan extension duration is out of bounds.\r\n     */\r\n    error InvalidExtensionDuration(uint256 duration, uint256 limit);\r\n\r\n    /**\r\n     * @notice Thrown when MultiToken.Asset is invalid.\r\n     * @dev Could be because of invalid category, address, id or amount.\r\n     */\r\n    error InvalidMultiTokenAsset(uint8 category, address addr, uint256 id, uint256 amount);\r\n\r\n    /**\r\n     * @notice Thrown when loan cannot be claimed on repayment.\r\n     */\r\n    error LoanNotAutoclaimable();\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # CONSTRUCTOR                                           *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    constructor(\r\n        address _hub,\r\n        address _loanToken,\r\n        address _config,\r\n        address _revokedNonce,\r\n        address _categoryRegistry\r\n    ) {\r\n        hub = PWNHub(_hub);\r\n        loanToken = PWNLOAN(_loanToken);\r\n        config = PWNConfig(_config);\r\n        revokedNonce = PWNRevokedNonce(_revokedNonce);\r\n        categoryRegistry = IMultiTokenCategoryRegistry(_categoryRegistry);\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # LENDER SPEC                                           *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Get hash of a lender specification.\r\n     * @param lenderSpec Lender specification struct.\r\n     * @return Hash of a lender specification.\r\n     */\r\n    function getLenderSpecHash(LenderSpec calldata lenderSpec) public pure returns (bytes32) {\r\n        return keccak256(abi.encode(lenderSpec));\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # CREATE LOAN                                           *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Create a new loan.\r\n     * @dev The function assumes a prior token approval to a contract address.\r\n     * @param proposalSpec Proposal specification struct.\r\n     * @param lenderSpec Lender specification struct.\r\n     * @param callerSpec Caller specification struct.\r\n     * @param extra Auxiliary data that are emitted in the loan creation event. They are not used in the contract logic.\r\n     * @return loanId Id of the created LOAN token.\r\n     */\r\n    function createLOAN(\r\n        ProposalSpec calldata proposalSpec,\r\n        LenderSpec calldata lenderSpec,\r\n        CallerSpec calldata callerSpec,\r\n        bytes calldata extra\r\n    ) external nonReentrant returns (uint256 loanId) {\r\n        // Check provided proposal contract\r\n        if (!hub.hasTag(proposalSpec.proposalContract, PWNHubTags.LOAN_PROPOSAL)) {\r\n            revert AddressMissingHubTag({ addr: proposalSpec.proposalContract, tag: PWNHubTags.LOAN_PROPOSAL });\r\n        }\r\n\r\n        // Revoke nonce if needed\r\n        if (callerSpec.revokeNonce) {\r\n            revokedNonce.revokeNonce(msg.sender, callerSpec.nonce);\r\n        }\r\n\r\n        // When refinancing a loan, move the original loan to repaid state\r\n        if (callerSpec.refinancingLoanId != 0) {\r\n            LOAN storage loan = LOANs[callerSpec.refinancingLoanId];\r\n            _checkLoanCanBeRepaid(loan.status, loan.defaultTimestamp);\r\n\r\n            // Update loan to repaid state\r\n            _updateRepaidLoan(callerSpec.refinancingLoanId);\r\n        }\r\n\r\n        // Accept proposal and get loan terms\r\n        (bytes32 proposalHash, Terms memory loanTerms) = PWNSimpleLoanProposal(proposalSpec.proposalContract)\r\n            .acceptProposal({\r\n                acceptor: msg.sender,\r\n                refinancingLoanId: callerSpec.refinancingLoanId,\r\n                proposalData: proposalSpec.proposalData,\r\n                proposalInclusionProof: proposalSpec.proposalInclusionProof,\r\n                signature: proposalSpec.signature\r\n            });\r\n\r\n        // Check that provided lender spec is correct\r\n        if (msg.sender != loanTerms.lender \u0026\u0026 loanTerms.lenderSpecHash != getLenderSpecHash(lenderSpec)) {\r\n            revert InvalidLenderSpecHash({ current: loanTerms.lenderSpecHash, expected: getLenderSpecHash(lenderSpec) });\r\n        }\r\n\r\n        // Check minimum loan duration\r\n        if (loanTerms.duration \u003c MIN_LOAN_DURATION) {\r\n            revert InvalidDuration({ current: loanTerms.duration, limit: MIN_LOAN_DURATION });\r\n        }\r\n\r\n        // Check maximum accruing interest APR\r\n        if (loanTerms.accruingInterestAPR \u003e MAX_ACCRUING_INTEREST_APR) {\r\n            revert InterestAPROutOfBounds({ current: loanTerms.accruingInterestAPR, limit: MAX_ACCRUING_INTEREST_APR });\r\n        }\r\n\r\n        if (callerSpec.refinancingLoanId == 0) {\r\n            // Check loan credit and collateral validity\r\n            _checkValidAsset(loanTerms.credit);\r\n            _checkValidAsset(loanTerms.collateral);\r\n        } else {\r\n            // Check refinance loan terms\r\n            _checkRefinanceLoanTerms(callerSpec.refinancingLoanId, loanTerms);\r\n        }\r\n\r\n        // Create a new loan\r\n        loanId = _createLoan({\r\n            loanTerms: loanTerms,\r\n            lenderSpec: lenderSpec\r\n        });\r\n\r\n        emit LOANCreated({\r\n            loanId: loanId,\r\n            proposalHash: proposalHash,\r\n            proposalContract: proposalSpec.proposalContract,\r\n            refinancingLoanId: callerSpec.refinancingLoanId,\r\n            terms: loanTerms,\r\n            lenderSpec: lenderSpec,\r\n            extra: extra\r\n        });\r\n\r\n        // Settle the loan\r\n        if (callerSpec.refinancingLoanId == 0) {\r\n            // Transfer collateral to Vault and credit to borrower\r\n            _settleNewLoan(loanTerms, lenderSpec);\r\n        } else {\r\n            // Repay the original loan and transfer the surplus to the borrower if any\r\n            _settleLoanRefinance({\r\n                refinancingLoanId: callerSpec.refinancingLoanId,\r\n                loanTerms: loanTerms,\r\n                lenderSpec: lenderSpec\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the loan terms are valid for refinancing.\r\n     * @dev The function will revert if the loan terms are not valid for refinancing.\r\n     * @param loanId Original loan id.\r\n     * @param loanTerms Refinancing loan terms struct.\r\n     */\r\n    function _checkRefinanceLoanTerms(uint256 loanId, Terms memory loanTerms) private view {\r\n        LOAN storage loan = LOANs[loanId];\r\n\r\n        // Check that the credit asset is the same as in the original loan\r\n        // Note: Address check is enough because the asset has always ERC20 category and zero id.\r\n        // Amount can be different, but nonzero.\r\n        if (\r\n            loan.creditAddress != loanTerms.credit.assetAddress ||\r\n            loanTerms.credit.amount == 0\r\n        ) revert RefinanceCreditMismatch();\r\n\r\n        // Check that the collateral is identical to the original one\r\n        if (\r\n            loan.collateral.category != loanTerms.collateral.category ||\r\n            loan.collateral.assetAddress != loanTerms.collateral.assetAddress ||\r\n            loan.collateral.id != loanTerms.collateral.id ||\r\n            loan.collateral.amount != loanTerms.collateral.amount\r\n        ) revert RefinanceCollateralMismatch();\r\n\r\n        // Check that the borrower is the same as in the original loan\r\n        if (loan.borrower != loanTerms.borrower) {\r\n            revert RefinanceBorrowerMismatch({\r\n                currentBorrower: loan.borrower,\r\n                newBorrower: loanTerms.borrower\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Mint LOAN token and store loan data under loan id.\r\n     * @param loanTerms Loan terms struct.\r\n     * @param lenderSpec Lender specification struct.\r\n     */\r\n    function _createLoan(\r\n        Terms memory loanTerms,\r\n        LenderSpec calldata lenderSpec\r\n    ) private returns (uint256 loanId) {\r\n        // Mint LOAN token for lender\r\n        loanId = loanToken.mint(loanTerms.lender);\r\n\r\n        // Store loan data under loan id\r\n        LOAN storage loan = LOANs[loanId];\r\n        loan.status = 2;\r\n        loan.creditAddress = loanTerms.credit.assetAddress;\r\n        loan.originalSourceOfFunds = lenderSpec.sourceOfFunds;\r\n        loan.startTimestamp = uint40(block.timestamp);\r\n        loan.defaultTimestamp = uint40(block.timestamp) + loanTerms.duration;\r\n        loan.borrower = loanTerms.borrower;\r\n        loan.originalLender = loanTerms.lender;\r\n        loan.accruingInterestAPR = loanTerms.accruingInterestAPR;\r\n        loan.fixedInterestAmount = loanTerms.fixedInterestAmount;\r\n        loan.principalAmount = loanTerms.credit.amount;\r\n        loan.collateral = loanTerms.collateral;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer collateral to Vault and credit to borrower.\r\n     * @dev The function assumes a prior token approval to a contract address.\r\n     * @param loanTerms Loan terms struct.\r\n     */\r\n    function _settleNewLoan(\r\n        Terms memory loanTerms,\r\n        LenderSpec calldata lenderSpec\r\n    ) private {\r\n        // Transfer collateral to Vault\r\n        _pull(loanTerms.collateral, loanTerms.borrower);\r\n\r\n        // Lender is not the source of funds\r\n        if (lenderSpec.sourceOfFunds != loanTerms.lender) {\r\n            // Withdraw credit asset to the lender first\r\n            _withdrawCreditFromPool(loanTerms.credit, loanTerms, lenderSpec);\r\n        }\r\n\r\n        // Calculate fee amount and new loan amount\r\n        (uint256 feeAmount, uint256 newLoanAmount)\r\n            = PWNFeeCalculator.calculateFeeAmount(config.fee(), loanTerms.credit.amount);\r\n\r\n        // Note: `creditHelper` must not be used before updating the amount.\r\n        MultiToken.Asset memory creditHelper = loanTerms.credit;\r\n\r\n        // Collect fees\r\n        if (feeAmount \u003e 0) {\r\n            creditHelper.amount = feeAmount;\r\n            _pushFrom(creditHelper, loanTerms.lender, config.feeCollector());\r\n        }\r\n\r\n        // Transfer credit to borrower\r\n        creditHelper.amount = newLoanAmount;\r\n        _pushFrom(creditHelper, loanTerms.lender, loanTerms.borrower);\r\n    }\r\n\r\n    /**\r\n     * @notice Settle the refinanced loan. If the new lender is the same as the current LOAN owner,\r\n     *         the function will transfer only the surplus to the borrower, if any.\r\n     *         If the new loan amount is not enough to cover the original loan, the borrower needs to contribute.\r\n     *         The function assumes a prior token approval to a contract address.\r\n     * @param refinancingLoanId Id of a loan to be refinanced.\r\n     * @param loanTerms Loan terms struct.\r\n     * @param lenderSpec Lender specification struct.\r\n     */\r\n    function _settleLoanRefinance(\r\n        uint256 refinancingLoanId,\r\n        Terms memory loanTerms,\r\n        LenderSpec calldata lenderSpec\r\n    ) private {\r\n        LOAN storage loan = LOANs[refinancingLoanId];\r\n        address loanOwner = loanToken.ownerOf(refinancingLoanId);\r\n        uint256 repaymentAmount = loanRepaymentAmount(refinancingLoanId);\r\n\r\n        // Calculate fee amount and new loan amount\r\n        (uint256 feeAmount, uint256 newLoanAmount)\r\n            = PWNFeeCalculator.calculateFeeAmount(config.fee(), loanTerms.credit.amount);\r\n\r\n        uint256 common = Math.min(repaymentAmount, newLoanAmount);\r\n        uint256 surplus = newLoanAmount \u003e repaymentAmount ? newLoanAmount - repaymentAmount : 0;\r\n        uint256 shortage = surplus \u003e 0 ? 0 : repaymentAmount - newLoanAmount;\r\n\r\n        // Note: New lender will always transfer common loan amount to the Vault, except when:\r\n        // - the new lender is the current loan owner but not the original lender\r\n        // - the new lender is the current loan owner, is the original lender, and the new and original source of funds are equal\r\n\r\n        bool shouldTransferCommon =\r\n            loanTerms.lender != loanOwner ||\r\n            (loan.originalLender == loanOwner \u0026\u0026 loan.originalSourceOfFunds != lenderSpec.sourceOfFunds);\r\n\r\n        // Note: `creditHelper` must not be used before updating the amount.\r\n        MultiToken.Asset memory creditHelper = loanTerms.credit;\r\n\r\n        // Lender is not the source of funds\r\n        if (lenderSpec.sourceOfFunds != loanTerms.lender) {\r\n            // Withdraw credit asset to the lender first\r\n            creditHelper.amount = feeAmount + (shouldTransferCommon ? common : 0) + surplus;\r\n            _withdrawCreditFromPool(creditHelper, loanTerms, lenderSpec);\r\n        }\r\n\r\n        // Collect fees\r\n        if (feeAmount \u003e 0) {\r\n            creditHelper.amount = feeAmount;\r\n            _pushFrom(creditHelper, loanTerms.lender, config.feeCollector());\r\n        }\r\n\r\n        // Transfer common amount to the Vault if necessary\r\n        if (shouldTransferCommon) {\r\n            creditHelper.amount = common;\r\n            _pull(creditHelper, loanTerms.lender);\r\n        }\r\n\r\n        // Handle the surplus or the shortage\r\n        if (surplus \u003e 0) {\r\n            // New loan covers the whole original loan, transfer surplus to the borrower\r\n            creditHelper.amount = surplus;\r\n            _pushFrom(creditHelper, loanTerms.lender, loanTerms.borrower);\r\n        } else if (shortage \u003e 0) {\r\n            // New loan covers only part of the original loan, borrower needs to contribute\r\n            creditHelper.amount = shortage;\r\n            _pull(creditHelper, loanTerms.borrower);\r\n        }\r\n\r\n        // Try to repay directly\r\n        try this.tryClaimRepaidLOAN({\r\n            loanId: refinancingLoanId,\r\n            creditAmount: (shouldTransferCommon ? common : 0) + shortage,\r\n            loanOwner: loanOwner\r\n        }) {} catch {\r\n            // Note: Safe transfer or supply to a pool can fail. In that case the LOAN token stays in repaid state and\r\n            // waits for the LOAN token owner to claim the repaid credit. Otherwise lender would be able to prevent\r\n            // anybody from repaying the loan.\r\n\r\n            // Transfer loan common to the Vault if necessary\r\n            // Shortage part is already in the Vault\r\n            if (!shouldTransferCommon) {\r\n                creditHelper.amount = common;\r\n                if (lenderSpec.sourceOfFunds != loanTerms.lender) {\r\n                    // Lender is not the source of funds\r\n                    // Withdraw credit asset to the lender first\r\n                    _withdrawCreditFromPool(creditHelper, loanTerms, lenderSpec);\r\n                }\r\n                _pull(creditHelper, loanTerms.lender);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw a credit asset from a pool to the Vault.\r\n     * @dev The function will revert if pool doesn\u0027t have registered pool adapter.\r\n     * @param credit Asset to be pulled from the pool.\r\n     * @param loanTerms Loan terms struct.\r\n     * @param lenderSpec Lender specification struct.\r\n     */\r\n    function _withdrawCreditFromPool(\r\n        MultiToken.Asset memory credit,\r\n        Terms memory loanTerms,\r\n        LenderSpec calldata lenderSpec\r\n    ) private {\r\n        IPoolAdapter poolAdapter = config.getPoolAdapter(lenderSpec.sourceOfFunds);\r\n        if (address(poolAdapter) == address(0)) {\r\n            revert InvalidSourceOfFunds({ sourceOfFunds: lenderSpec.sourceOfFunds });\r\n        }\r\n\r\n        if (credit.amount \u003e 0) {\r\n            _withdrawFromPool(credit, poolAdapter, lenderSpec.sourceOfFunds, loanTerms.lender);\r\n        }\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # REPAY LOAN                                            *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Repay running loan.\r\n     * @dev Any address can repay a running loan, but a collateral will be transferred to a borrower address associated with the loan.\r\n     *      If the LOAN token holder is the same as the original lender, the repayment credit asset will be\r\n     *      transferred to the LOAN token holder directly. Otherwise it will transfer the repayment credit asset to\r\n     *      a vault, waiting on a LOAN token holder to claim it. The function assumes a prior token approval to a contract address.\r\n     * @param loanId Id of a loan that is being repaid.\r\n     */\r\n    function repayLOAN(uint256 loanId) external nonReentrant {\r\n        LOAN storage loan = LOANs[loanId];\r\n\r\n        _checkLoanCanBeRepaid(loan.status, loan.defaultTimestamp);\r\n\r\n        // Update loan to repaid state\r\n        _updateRepaidLoan(loanId);\r\n\r\n        // Transfer the repaid credit to the Vault\r\n        uint256 repaymentAmount = loanRepaymentAmount(loanId);\r\n        _pull(loan.creditAddress.ERC20(repaymentAmount), msg.sender);\r\n\r\n        // Transfer collateral back to borrower\r\n        _push(loan.collateral, loan.borrower);\r\n\r\n        // Try to repay directly\r\n        try this.tryClaimRepaidLOAN(loanId, repaymentAmount, loanToken.ownerOf(loanId)) {} catch {\r\n            // Note: Safe transfer or supply to a pool can fail. In that case leave the LOAN token in repaid state and\r\n            // wait for the LOAN token owner to claim the repaid credit. Otherwise lender would be able to prevent\r\n            // borrower from repaying the loan.\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the loan can be repaid.\r\n     * @dev The function will revert if the loan cannot be repaid.\r\n     * @param status Loan status.\r\n     * @param defaultTimestamp Loan default timestamp.\r\n     */\r\n    function _checkLoanCanBeRepaid(uint8 status, uint40 defaultTimestamp) private view {\r\n        // Check that loan exists and is not from a different loan contract\r\n        if (status == 0)\r\n            revert NonExistingLoan();\r\n        // Check that loan is running\r\n        if (status != 2)\r\n            revert LoanNotRunning();\r\n        // Check that loan is not defaulted\r\n        if (defaultTimestamp \u003c= block.timestamp)\r\n            revert LoanDefaulted({ timestap: defaultTimestamp });\r\n    }\r\n\r\n    /**\r\n     * @notice Update loan to repaid state.\r\n     * @param loanId Id of a loan that is being repaid.\r\n     */\r\n    function _updateRepaidLoan(uint256 loanId) private {\r\n        LOAN storage loan = LOANs[loanId];\r\n\r\n        // Move loan to repaid state and wait for the loan owner to claim the repaid credit\r\n        loan.status = 3;\r\n\r\n        // Update accrued interest amount\r\n        loan.fixedInterestAmount = _loanAccruedInterest(loan);\r\n        loan.accruingInterestAPR = 0;\r\n\r\n        // Note: Reusing `fixedInterestAmount` to store accrued interest at the time of repayment\r\n        // to have the value at the time of claim and stop accruing new interest.\r\n\r\n        emit LOANPaidBack({ loanId: loanId });\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # LOAN REPAYMENT AMOUNT                                 *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Calculate the loan repayment amount with fixed and accrued interest.\r\n     * @param loanId Id of a loan.\r\n     * @return Repayment amount.\r\n     */\r\n    function loanRepaymentAmount(uint256 loanId) public view returns (uint256) {\r\n        LOAN storage loan = LOANs[loanId];\r\n\r\n        // Check non-existent loan\r\n        if (loan.status == 0) return 0;\r\n\r\n        // Return loan principal with accrued interest\r\n        return loan.principalAmount + _loanAccruedInterest(loan);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the loan accrued interest.\r\n     * @param loan Loan data struct.\r\n     * @return Accrued interest amount.\r\n     */\r\n    function _loanAccruedInterest(LOAN storage loan) private view returns (uint256) {\r\n        if (loan.accruingInterestAPR == 0)\r\n            return loan.fixedInterestAmount;\r\n\r\n        uint256 accruingMinutes = (block.timestamp - loan.startTimestamp) / 1 minutes;\r\n        uint256 accruedInterest = Math.mulDiv(\r\n            loan.principalAmount, uint256(loan.accruingInterestAPR) * accruingMinutes, ACCRUING_INTEREST_APR_DENOMINATOR\r\n        );\r\n        return loan.fixedInterestAmount + accruedInterest;\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # CLAIM LOAN                                            *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Claim a repaid or defaulted loan.\r\n     * @dev Only a LOAN token holder can claim a repaid or defaulted loan.\r\n     *      Claim will transfer the repaid credit or collateral to a LOAN token holder address and burn the LOAN token.\r\n     * @param loanId Id of a loan that is being claimed.\r\n     */\r\n    function claimLOAN(uint256 loanId) external nonReentrant {\r\n        LOAN storage loan = LOANs[loanId];\r\n\r\n        // Check that caller is LOAN token holder\r\n        if (loanToken.ownerOf(loanId) != msg.sender)\r\n            revert CallerNotLOANTokenHolder();\r\n\r\n        if (loan.status == 0)\r\n            // Loan is not existing or from a different loan contract\r\n            revert NonExistingLoan();\r\n        else if (loan.status == 3)\r\n            // Loan has been paid back\r\n            _settleLoanClaim({ loanId: loanId, loanOwner: msg.sender, defaulted: false });\r\n        else if (loan.status == 2 \u0026\u0026 loan.defaultTimestamp \u003c= block.timestamp)\r\n            // Loan is running but expired\r\n            _settleLoanClaim({ loanId: loanId, loanOwner: msg.sender, defaulted: true });\r\n        else\r\n            // Loan is in wrong state\r\n            revert LoanRunning();\r\n    }\r\n\r\n    /**\r\n     * @notice Try to claim a repaid loan for the loan owner.\r\n     * @dev The function is called by the vault to repay a loan directly to the original lender or its source of funds\r\n     *      if the loan owner is the original lender. If the transfer fails, the LOAN token will remain in repaid state\r\n     *      and the LOAN token owner will be able to claim the repaid credit. Otherwise lender would be able to prevent\r\n     *      borrower from repaying the loan.\r\n     * @param loanId Id of a loan that is being claimed.\r\n     * @param creditAmount Amount of a credit to be claimed.\r\n     * @param loanOwner Address of the LOAN token holder.\r\n     */\r\n    function tryClaimRepaidLOAN(uint256 loanId, uint256 creditAmount, address loanOwner) external {\r\n        if (msg.sender != address(this))\r\n            revert CallerNotVault();\r\n\r\n        LOAN storage loan = LOANs[loanId];\r\n\r\n        // Loan must be in the repaid state\r\n        if (loan.status != 3)\r\n            revert LoanNotRepaid();\r\n\r\n        // If current loan owner is not original lender, the loan cannot be repaid directly, return without revert.\r\n        if (loan.originalLender != loanOwner)\r\n            revert LoanNotAutoclaimable();\r\n\r\n        // Note: The loan owner is the original lender at this point.\r\n\r\n        address destinationOfFunds = loan.originalSourceOfFunds;\r\n        MultiToken.Asset memory repaymentCredit = loan.creditAddress.ERC20(creditAmount);\r\n\r\n        // Delete loan data \u0026 burn LOAN token before calling safe transfer\r\n        _deleteLoan(loanId);\r\n\r\n        emit LOANClaimed({ loanId: loanId, defaulted: false });\r\n\r\n        // End here if the credit amount is zero\r\n        if (creditAmount == 0)\r\n            return;\r\n\r\n        // Note: Zero credit amount can happen when the loan is refinanced by the original lender.\r\n\r\n        // Repay the original lender\r\n        if (destinationOfFunds == loanOwner) {\r\n            _push(repaymentCredit, loanOwner);\r\n        } else {\r\n            IPoolAdapter poolAdapter = config.getPoolAdapter(destinationOfFunds);\r\n            // Check that pool has registered adapter\r\n            if (address(poolAdapter) == address(0)) {\r\n\r\n                // Note: Adapter can be unregistered during the loan lifetime, so the pool might not have an adapter.\r\n                // In that case, the loan owner will be able to claim the repaid credit.\r\n\r\n                revert InvalidSourceOfFunds({ sourceOfFunds: destinationOfFunds });\r\n            }\r\n\r\n            // Supply the repaid credit to the original pool\r\n            _supplyToPool(repaymentCredit, poolAdapter, destinationOfFunds, loanOwner);\r\n        }\r\n\r\n        // Note: If the transfer fails, the LOAN token will remain in repaid state and the LOAN token owner\r\n        // will be able to claim the repaid credit. Otherwise lender would be able to prevent borrower from\r\n        // repaying the loan.\r\n    }\r\n\r\n    /**\r\n     * @notice Settle the loan claim.\r\n     * @param loanId Id of a loan that is being claimed.\r\n     * @param loanOwner Address of the LOAN token holder.\r\n     * @param defaulted If the loan is defaulted.\r\n     */\r\n    function _settleLoanClaim(uint256 loanId, address loanOwner, bool defaulted) private {\r\n        LOAN storage loan = LOANs[loanId];\r\n\r\n        // Store in memory before deleting the loan\r\n        MultiToken.Asset memory asset = defaulted\r\n            ? loan.collateral\r\n            : loan.creditAddress.ERC20(loanRepaymentAmount(loanId));\r\n\r\n        // Delete loan data \u0026 burn LOAN token before calling safe transfer\r\n        _deleteLoan(loanId);\r\n\r\n        emit LOANClaimed({ loanId: loanId, defaulted: defaulted });\r\n\r\n        // Transfer asset to current LOAN token owner\r\n        _push(asset, loanOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Delete loan data and burn LOAN token.\r\n     * @param loanId Id of a loan that is being deleted.\r\n     */\r\n    function _deleteLoan(uint256 loanId) private {\r\n        loanToken.burn(loanId);\r\n        delete LOANs[loanId];\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # EXTEND LOAN                                           *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Make an on-chain extension proposal.\r\n     * @param extension Extension proposal struct.\r\n     */\r\n    function makeExtensionProposal(ExtensionProposal calldata extension) external {\r\n        // Check that caller is a proposer\r\n        if (msg.sender != extension.proposer)\r\n            revert InvalidExtensionSigner({ allowed: extension.proposer, current: msg.sender });\r\n\r\n        // Mark extension proposal as made\r\n        bytes32 extensionHash = getExtensionHash(extension);\r\n        extensionProposalsMade[extensionHash] = true;\r\n\r\n        emit ExtensionProposalMade(extensionHash, extension.proposer, extension);\r\n    }\r\n\r\n    /**\r\n     * @notice Extend loans default date with signed extension proposal signed by borrower or LOAN token owner.\r\n     * @dev The function assumes a prior token approval to a contract address.\r\n     * @param extension Extension proposal struct.\r\n     * @param signature Signature of the extension proposal.\r\n     */\r\n    function extendLOAN(\r\n        ExtensionProposal calldata extension,\r\n        bytes calldata signature\r\n    ) external nonReentrant {\r\n        LOAN storage loan = LOANs[extension.loanId];\r\n\r\n        // Check that loan is in the right state\r\n        if (loan.status == 0)\r\n            revert NonExistingLoan();\r\n        if (loan.status == 3) // cannot extend repaid loan\r\n            revert LoanRepaid();\r\n\r\n        // Check extension validity\r\n        bytes32 extensionHash = getExtensionHash(extension);\r\n        if (!extensionProposalsMade[extensionHash])\r\n            if (!PWNSignatureChecker.isValidSignatureNow(extension.proposer, extensionHash, signature))\r\n                revert PWNSignatureChecker.InvalidSignature({ signer: extension.proposer, digest: extensionHash });\r\n\r\n        // Check extension expiration\r\n        if (block.timestamp \u003e= extension.expiration)\r\n            revert Expired({ current: block.timestamp, expiration: extension.expiration });\r\n\r\n        // Check extension nonce\r\n        if (!revokedNonce.isNonceUsable(extension.proposer, extension.nonceSpace, extension.nonce))\r\n            revert PWNRevokedNonce.NonceNotUsable({\r\n                addr: extension.proposer,\r\n                nonceSpace: extension.nonceSpace,\r\n                nonce: extension.nonce\r\n            });\r\n\r\n        // Check caller and signer\r\n        address loanOwner = loanToken.ownerOf(extension.loanId);\r\n        if (msg.sender == loanOwner) {\r\n            if (extension.proposer != loan.borrower) {\r\n                // If caller is loan owner, proposer must be borrower\r\n                revert InvalidExtensionSigner({\r\n                    allowed: loan.borrower,\r\n                    current: extension.proposer\r\n                });\r\n            }\r\n        } else if (msg.sender == loan.borrower) {\r\n            if (extension.proposer != loanOwner) {\r\n                // If caller is borrower, proposer must be loan owner\r\n                revert InvalidExtensionSigner({\r\n                    allowed: loanOwner,\r\n                    current: extension.proposer\r\n                });\r\n            }\r\n        } else {\r\n            // Caller must be loan owner or borrower\r\n            revert InvalidExtensionCaller();\r\n        }\r\n\r\n        // Check duration range\r\n        if (extension.duration \u003c MIN_EXTENSION_DURATION)\r\n            revert InvalidExtensionDuration({\r\n                duration: extension.duration,\r\n                limit: MIN_EXTENSION_DURATION\r\n            });\r\n        if (extension.duration \u003e MAX_EXTENSION_DURATION)\r\n            revert InvalidExtensionDuration({\r\n                duration: extension.duration,\r\n                limit: MAX_EXTENSION_DURATION\r\n            });\r\n\r\n        // Revoke extension proposal nonce\r\n        revokedNonce.revokeNonce(extension.proposer, extension.nonceSpace, extension.nonce);\r\n\r\n        // Update loan\r\n        uint40 originalDefaultTimestamp = loan.defaultTimestamp;\r\n        loan.defaultTimestamp = originalDefaultTimestamp + extension.duration;\r\n\r\n        // Emit event\r\n        emit LOANExtended({\r\n            loanId: extension.loanId,\r\n            originalDefaultTimestamp: originalDefaultTimestamp,\r\n            extendedDefaultTimestamp: loan.defaultTimestamp\r\n        });\r\n\r\n        // Skip compensation transfer if it\u0027s not set\r\n        if (extension.compensationAddress != address(0) \u0026\u0026 extension.compensationAmount \u003e 0) {\r\n            MultiToken.Asset memory compensation = extension.compensationAddress.ERC20(extension.compensationAmount);\r\n\r\n            // Check compensation asset validity\r\n            _checkValidAsset(compensation);\r\n\r\n            // Transfer compensation to the loan owner\r\n            _pushFrom(compensation, loan.borrower, loanOwner);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the hash of the extension struct.\r\n     * @param extension Extension proposal struct.\r\n     * @return Hash of the extension struct.\r\n     */\r\n    function getExtensionHash(ExtensionProposal calldata extension) public view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\r\n            hex\"1901\",\r\n            DOMAIN_SEPARATOR,\r\n            keccak256(abi.encodePacked(\r\n                EXTENSION_PROPOSAL_TYPEHASH,\r\n                abi.encode(extension)\r\n            ))\r\n        ));\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # GET LOAN                                              *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Return a LOAN data struct associated with a loan id.\r\n     * @param loanId Id of a loan in question.\r\n     * @return status LOAN status.\r\n     * @return startTimestamp Unix timestamp (in seconds) of a loan creation date.\r\n     * @return defaultTimestamp Unix timestamp (in seconds) of a loan default date.\r\n     * @return borrower Address of a loan borrower.\r\n     * @return originalLender Address of a loan original lender.\r\n     * @return loanOwner Address of a LOAN token holder.\r\n     * @return accruingInterestAPR Accruing interest APR with 2 decimal places.\r\n     * @return fixedInterestAmount Fixed interest amount in credit asset tokens.\r\n     * @return credit Asset used as a loan credit. For a definition see { MultiToken dependency lib }.\r\n     * @return collateral Asset used as a loan collateral. For a definition see { MultiToken dependency lib }.\r\n     * @return originalSourceOfFunds Address of a source of funds for the loan. Original lender address, if the loan was funded directly, or a pool address from witch credit funds were withdrawn / borrowred.\r\n     * @return repaymentAmount Loan repayment amount in credit asset tokens.\r\n     */\r\n    function getLOAN(uint256 loanId) external view returns (\r\n        uint8 status,\r\n        uint40 startTimestamp,\r\n        uint40 defaultTimestamp,\r\n        address borrower,\r\n        address originalLender,\r\n        address loanOwner,\r\n        uint24 accruingInterestAPR,\r\n        uint256 fixedInterestAmount,\r\n        MultiToken.Asset memory credit,\r\n        MultiToken.Asset memory collateral,\r\n        address originalSourceOfFunds,\r\n        uint256 repaymentAmount\r\n    ) {\r\n        LOAN storage loan = LOANs[loanId];\r\n\r\n        status = _getLOANStatus(loanId);\r\n        startTimestamp = loan.startTimestamp;\r\n        defaultTimestamp = loan.defaultTimestamp;\r\n        borrower = loan.borrower;\r\n        originalLender = loan.originalLender;\r\n        loanOwner = loan.status != 0 ? loanToken.ownerOf(loanId) : address(0);\r\n        accruingInterestAPR = loan.accruingInterestAPR;\r\n        fixedInterestAmount = loan.fixedInterestAmount;\r\n        credit = loan.creditAddress.ERC20(loan.principalAmount);\r\n        collateral = loan.collateral;\r\n        originalSourceOfFunds = loan.originalSourceOfFunds;\r\n        repaymentAmount = loanRepaymentAmount(loanId);\r\n    }\r\n\r\n    /**\r\n     * @notice Return a LOAN status associated with a loan id.\r\n     * @param loanId Id of a loan in question.\r\n     * @return status LOAN status.\r\n     */\r\n    function _getLOANStatus(uint256 loanId) private view returns (uint8) {\r\n        LOAN storage loan = LOANs[loanId];\r\n        return (loan.status == 2 \u0026\u0026 loan.defaultTimestamp \u003c= block.timestamp) ? 4 : loan.status;\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # MultiToken                                            *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Check if the asset is valid with the MultiToken dependency lib and the category registry.\r\n     * @dev See MultiToken.isValid for more details.\r\n     * @param asset Asset to be checked.\r\n     * @return True if the asset is valid.\r\n     */\r\n    function isValidAsset(MultiToken.Asset memory asset) public view returns (bool) {\r\n        return MultiToken.isValid(asset, categoryRegistry);\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the asset is valid with the MultiToken lib and the category registry.\r\n     * @dev The function will revert if the asset is not valid.\r\n     * @param asset Asset to be checked.\r\n     */\r\n    function _checkValidAsset(MultiToken.Asset memory asset) private view {\r\n        if (!isValidAsset(asset)) {\r\n            revert InvalidMultiTokenAsset({\r\n                category: uint8(asset.category),\r\n                addr: asset.assetAddress,\r\n                id: asset.id,\r\n                amount: asset.amount\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # IPWNLoanMetadataProvider                              *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @inheritdoc IPWNLoanMetadataProvider\r\n     */\r\n    function loanMetadataUri() override external view returns (string memory) {\r\n        return config.loanMetadataUri(address(this));\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # ERC5646                                               *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @inheritdoc IERC5646\r\n     */\r\n    function getStateFingerprint(uint256 tokenId) external view virtual override returns (bytes32) {\r\n        LOAN storage loan = LOANs[tokenId];\r\n\r\n        if (loan.status == 0)\r\n            return bytes32(0);\r\n\r\n        // The only mutable state properties are:\r\n        // - status: updated for expired loans based on block.timestamp\r\n        // - defaultTimestamp: updated when the loan is extended\r\n        // - fixedInterestAmount: updated when the loan is repaid and waiting to be claimed\r\n        // - accruingInterestAPR: updated when the loan is repaid and waiting to be claimed\r\n        // Others don\u0027t have to be part of the state fingerprint as it does not act as a token identification.\r\n        return keccak256(abi.encode(\r\n            _getLOANStatus(tokenId),\r\n            loan.defaultTimestamp,\r\n            loan.fixedInterestAmount,\r\n            loan.accruingInterestAPR\r\n        ));\r\n    }\r\n\r\n}\r\n"
        },
        "src/loan/terms/simple/proposal/PWNSimpleLoanElasticChainlinkProposal.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport { MultiToken } from \"MultiToken/MultiToken.sol\";\r\n\r\nimport { Math } from \"openzeppelin/utils/math/Math.sol\";\r\n\r\nimport {\r\n    Chainlink,\r\n    IChainlinkFeedRegistryLike,\r\n    IChainlinkAggregatorLike\r\n} from \"pwn/loan/lib/Chainlink.sol\";\r\nimport { PWNSimpleLoan } from \"pwn/loan/terms/simple/loan/PWNSimpleLoan.sol\";\r\nimport { PWNSimpleLoanProposal } from \"pwn/loan/terms/simple/proposal/PWNSimpleLoanProposal.sol\";\r\nimport { safeFetchDecimals } from \"pwn/loan/utils/safeFetchDecimals.sol\";\r\n\r\n\r\n/**\r\n * @title PWN Simple Loan Elastic Chainlink Proposal\r\n * @notice Contract for creating and accepting elastic loan proposals using Chainlink oracles.\r\n *         Proposals are elastic, which means that they are not tied to a specific collateral or credit amount.\r\n *         The amount of collateral and credit is specified during the proposal acceptance.\r\n */\r\ncontract PWNSimpleLoanElasticChainlinkProposal is PWNSimpleLoanProposal {\r\n    using Chainlink for IChainlinkFeedRegistryLike;\r\n    using Chainlink for IChainlinkAggregatorLike;\r\n\r\n    string public constant VERSION = \"1.0\";\r\n\r\n    uint256 public constant MAX_INTERMEDIARY_DENOMINATIONS = 2;\r\n\r\n    /**\r\n     * @notice Loan to value denominator. It is used to calculate collateral amount from credit amount.\r\n     */\r\n    uint256 public constant LOAN_TO_VALUE_DENOMINATOR = 1e4;\r\n\r\n    /**\r\n     * @dev EIP-712 simple proposal struct type hash.\r\n     */\r\n    bytes32 public constant PROPOSAL_TYPEHASH = keccak256(\r\n        \"Proposal(uint8 collateralCategory,address collateralAddress,uint256 collateralId,bool checkCollateralStateFingerprint,bytes32 collateralStateFingerprint,address creditAddress,address[] feedIntermediaryDenominations,bool[] feedInvertFlags,uint256 loanToValue,uint256 minCreditAmount,uint256 availableCreditLimit,bytes32 utilizedCreditId,uint256 fixedInterestAmount,uint24 accruingInterestAPR,uint32 durationOrDate,uint40 expiration,address allowedAcceptor,address proposer,bytes32 proposerSpecHash,bool isOffer,uint256 refinancingLoanId,uint256 nonceSpace,uint256 nonce,address loanContract)\"\r\n    );\r\n\r\n    /**\r\n     * @notice Construct defining an elastic chainlink proposal.\r\n     * @param collateralCategory Category of an asset used as a collateral (0 == ERC20, 1 == ERC721, 2 == ERC1155).\r\n     * @param collateralAddress Address of an asset used as a collateral.\r\n     * @param collateralId Token id of an asset used as a collateral, in case of ERC20 should be 0.\r\n     * @param checkCollateralStateFingerprint If true, the collateral state fingerprint will be checked during proposal acceptance.\r\n     * @param collateralStateFingerprint Fingerprint of a collateral state. It is used to check if a collateral is in a valid state.\r\n     * @param creditAddress Address of an asset which is lended to a borrower.\r\n     * @param feedIntermediaryDenominations List of intermediary price feeds that will be fetched to get to the collateral asset denominator.\r\n     * @param feedInvertFlags List of flags indicating if price feeds exist only for inverted base and quote assets.\r\n     * @param loanToValue Loan to value ratio with 4 decimals. E.g., 6231 == 0.6231 == 62.31%.\r\n     * @param minCreditAmount Minimum amount of tokens which can be borrowed using the proposal.\r\n     * @param availableCreditLimit Available credit limit for the proposal. It is the maximum amount of tokens which can be borrowed using the proposal. If non-zero, proposal can be accepted more than once, until the credit limit is reached.\r\n     * @param utilizedCreditId Id of utilized credit. Can be shared between multiple proposals.\r\n     * @param fixedInterestAmount Fixed interest amount in credit tokens. It is the minimum amount of interest which has to be paid by a borrower.\r\n     * @param accruingInterestAPR Accruing interest APR with 2 decimals.\r\n     * @param durationOrDate Duration of a loan in seconds. If the value is greater than 10^9, it is treated as a timestamp of a loan end.\r\n     * @param expiration Proposal expiration timestamp in seconds.\r\n     * @param allowedAcceptor Address that is allowed to accept proposal. If the address is zero address, anybody can accept the proposal.\r\n     * @param proposer Address of a proposal signer. If `isOffer` is true, the proposer is the lender. If `isOffer` is false, the proposer is the borrower.\r\n     * @param proposerSpecHash Hash of a proposer specific data, which must be provided during a loan creation.\r\n     * @param isOffer If true, the proposal is an offer. If false, the proposal is a request.\r\n     * @param refinancingLoanId Id of a loan which is refinanced by this proposal. If the id is 0 and `isOffer` is true, the proposal can refinance any loan.\r\n     * @param nonceSpace Nonce space of a proposal nonce. All nonces in the same space can be revoked at once.\r\n     * @param nonce Additional value to enable identical proposals in time. Without it, it would be impossible to make again proposal, which was once revoked. Can be used to create a group of proposals, where accepting one will make others in the group invalid.\r\n     * @param loanContract Address of a loan contract that will create a loan from the proposal.\r\n     */\r\n    struct Proposal {\r\n        MultiToken.Category collateralCategory;\r\n        address collateralAddress;\r\n        uint256 collateralId;\r\n        bool checkCollateralStateFingerprint;\r\n        bytes32 collateralStateFingerprint;\r\n        address creditAddress;\r\n        address[] feedIntermediaryDenominations;\r\n        bool[] feedInvertFlags;\r\n        uint256 loanToValue;\r\n        uint256 minCreditAmount;\r\n        uint256 availableCreditLimit;\r\n        bytes32 utilizedCreditId;\r\n        uint256 fixedInterestAmount;\r\n        uint24 accruingInterestAPR;\r\n        uint32 durationOrDate;\r\n        uint40 expiration;\r\n        address allowedAcceptor;\r\n        address proposer;\r\n        bytes32 proposerSpecHash;\r\n        bool isOffer;\r\n        uint256 refinancingLoanId;\r\n        uint256 nonceSpace;\r\n        uint256 nonce;\r\n        address loanContract;\r\n    }\r\n\r\n    /**\r\n     * @notice Construct defining proposal concrete values.\r\n     * @param creditAmount Amount of credit to be borrowed.\r\n     */\r\n    struct ProposalValues {\r\n        uint256 creditAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Chainlink feed registry contract.\r\n     */\r\n    IChainlinkFeedRegistryLike public immutable chainlinkFeedRegistry;\r\n\r\n    /**\r\n     * @notice Chainlink feed for L2 Sequencer uptime.\r\n     * @dev Must be address(0) for L1s.\r\n     */\r\n    IChainlinkAggregatorLike public immutable l2SequencerUptimeFeed;\r\n\r\n    /**\r\n     * @notice WETH address.\r\n     * @dev WETH price is fetched from the ETH price feed.\r\n     */\r\n    address public immutable WETH;\r\n\r\n    /**\r\n     * @notice Emitted when a proposal is made via an on-chain transaction.\r\n     */\r\n    event ProposalMade(bytes32 indexed proposalHash, address indexed proposer, Proposal proposal);\r\n\r\n    /**\r\n     * @notice Thrown when proposal has no minimum credit amount set.\r\n     */\r\n    error MinCreditAmountNotSet();\r\n\r\n    /**\r\n     * @notice Thrown when proposal credit amount is insufficient.\r\n     */\r\n    error InsufficientCreditAmount(uint256 current, uint256 limit);\r\n\r\n    /**\r\n     * @notice Thrown when intermediary denominations are out of bounds.\r\n     */\r\n    error IntermediaryDenominationsOutOfBounds(uint256 current, uint256 limit);\r\n\r\n\r\n    constructor(\r\n        address _hub,\r\n        address _revokedNonce,\r\n        address _config,\r\n        address _utilizedCredit,\r\n        address _chainlinkFeedRegistry,\r\n        address _l2SequencerUptimeFeed,\r\n        address _weth\r\n    ) PWNSimpleLoanProposal(_hub, _revokedNonce, _config, _utilizedCredit, \"PWNSimpleLoanElasticChainlinkProposal\", VERSION) {\r\n        chainlinkFeedRegistry = IChainlinkFeedRegistryLike(_chainlinkFeedRegistry);\r\n        l2SequencerUptimeFeed = IChainlinkAggregatorLike(_l2SequencerUptimeFeed);\r\n        WETH = _weth;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Get an proposal hash according to EIP-712\r\n     * @param proposal Proposal struct to be hashed.\r\n     * @return Proposal struct hash.\r\n     */\r\n    function getProposalHash(Proposal calldata proposal) public view returns (bytes32) {\r\n        return _getProposalHash(PROPOSAL_TYPEHASH, _erc712EncodeProposal(proposal));\r\n    }\r\n\r\n    /**\r\n     * @notice Make an on-chain proposal.\r\n     * @dev Function will mark a proposal hash as proposed.\r\n     * @param proposal Proposal struct containing all needed proposal data.\r\n     * @return proposalHash Proposal hash.\r\n     */\r\n    function makeProposal(Proposal calldata proposal) external returns (bytes32 proposalHash) {\r\n        proposalHash = getProposalHash(proposal);\r\n        _makeProposal(proposalHash, proposal.proposer);\r\n        emit ProposalMade(proposalHash, proposal.proposer, proposal);\r\n    }\r\n\r\n    /**\r\n     * @notice Encode proposal data.\r\n     * @param proposal Proposal struct to be encoded.\r\n     * @param proposalValues ProposalValues struct to be encoded.\r\n     * @return Encoded proposal data.\r\n     */\r\n    function encodeProposalData(\r\n        Proposal memory proposal,\r\n        ProposalValues memory proposalValues\r\n    ) external pure returns (bytes memory) {\r\n        return abi.encode(proposal, proposalValues);\r\n    }\r\n\r\n    /**\r\n     * @notice Decode proposal data.\r\n     * @param proposalData Encoded proposal data.\r\n     * @return Decoded proposal struct.\r\n     * @return Decoded proposal values struct.\r\n     */\r\n    function decodeProposalData(bytes memory proposalData) public pure returns (Proposal memory, ProposalValues memory) {\r\n        return abi.decode(proposalData, (Proposal, ProposalValues));\r\n    }\r\n\r\n    /**\r\n     * @notice Compute collateral amount from credit amount, LTV, and Chainlink price feeds.\r\n     * @param creditAddress Address of credit token.\r\n     * @param creditAmount Amount of credit.\r\n     * @param collateralAddress Address of collateral token.\r\n     * @param feedIntermediaryDenominations List of intermediary price feeds that will be fetched to get to the collateral asset denominator.\r\n     * @param feedInvertFlags List of flags indicating if price feeds exist only for inverted base and quote assets.\r\n     * @param loanToValue Loan to value ratio with 4 decimals. E.g., 6231 == 0.6231 == 62.31%.\r\n     * @return Amount of collateral.\r\n     */\r\n    function getCollateralAmount(\r\n        address creditAddress,\r\n        uint256 creditAmount,\r\n        address collateralAddress,\r\n        address[] memory feedIntermediaryDenominations,\r\n        bool[] memory feedInvertFlags,\r\n        uint256 loanToValue\r\n    ) public view returns (uint256) {\r\n        // check L2 sequencer uptime if necessary\r\n        l2SequencerUptimeFeed.checkSequencerUptime();\r\n\r\n        // don\u0027t allow more than 2 intermediary denominations\r\n        if (feedIntermediaryDenominations.length \u003e MAX_INTERMEDIARY_DENOMINATIONS) {\r\n            revert IntermediaryDenominationsOutOfBounds({\r\n                current: feedIntermediaryDenominations.length,\r\n                limit: MAX_INTERMEDIARY_DENOMINATIONS\r\n            });\r\n        }\r\n\r\n        // fetch credit asset price with collateral asset as denomination\r\n        // Note: use ETH price feed for WETH asset due to absence of WETH price feed\r\n        (uint256 price, uint8 priceDecimals) = chainlinkFeedRegistry.fetchCreditPriceWithCollateralDenomination({\r\n            creditAsset: creditAddress == WETH ? Chainlink.ETH : creditAddress,\r\n            collateralAsset: collateralAddress == WETH ? Chainlink.ETH : collateralAddress,\r\n            feedIntermediaryDenominations: feedIntermediaryDenominations,\r\n            feedInvertFlags: feedInvertFlags\r\n        });\r\n\r\n        // fetch asset decimals\r\n        uint256 creditDecimals = safeFetchDecimals(creditAddress);\r\n        uint256 collateralDecimals = safeFetchDecimals(collateralAddress);\r\n\r\n        if (collateralDecimals \u003e creditDecimals) {\r\n            creditAmount *= 10 ** (collateralDecimals - creditDecimals);\r\n        }\r\n\r\n        uint256 collateralAmount = Math.mulDiv(creditAmount, price, 10 ** priceDecimals);\r\n        collateralAmount = Math.mulDiv(collateralAmount, LOAN_TO_VALUE_DENOMINATOR, loanToValue);\r\n\r\n        if (collateralDecimals \u003c creditDecimals) {\r\n            collateralAmount /= 10 ** (creditDecimals - collateralDecimals);\r\n        }\r\n\r\n        return collateralAmount;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc PWNSimpleLoanProposal\r\n     */\r\n    function acceptProposal(\r\n        address acceptor,\r\n        uint256 refinancingLoanId,\r\n        bytes calldata proposalData,\r\n        bytes32[] calldata proposalInclusionProof,\r\n        bytes calldata signature\r\n    ) override external returns (bytes32 proposalHash, PWNSimpleLoan.Terms memory loanTerms) {\r\n        // Decode proposal data\r\n        (Proposal memory proposal, ProposalValues memory proposalValues) = decodeProposalData(proposalData);\r\n\r\n        // Make proposal hash\r\n        proposalHash = _getProposalHash(PROPOSAL_TYPEHASH, _erc712EncodeProposal(proposal));\r\n\r\n        // Check min credit amount\r\n        if (proposal.minCreditAmount == 0) {\r\n            revert MinCreditAmountNotSet();\r\n        }\r\n\r\n        // Check sufficient credit amount\r\n        if (proposalValues.creditAmount \u003c proposal.minCreditAmount) {\r\n            revert InsufficientCreditAmount({ current: proposalValues.creditAmount, limit: proposal.minCreditAmount });\r\n        }\r\n\r\n        // Calculate collateral amount\r\n        uint256 collateralAmount = getCollateralAmount(\r\n            proposal.creditAddress,\r\n            proposalValues.creditAmount,\r\n            proposal.collateralAddress,\r\n            proposal.feedIntermediaryDenominations,\r\n            proposal.feedInvertFlags,\r\n            proposal.loanToValue\r\n        );\r\n\r\n        // Try to accept proposal\r\n        _acceptProposal(\r\n            acceptor,\r\n            refinancingLoanId,\r\n            proposalHash,\r\n            proposalInclusionProof,\r\n            signature,\r\n            ProposalBase({\r\n                collateralAddress: proposal.collateralAddress,\r\n                collateralId: proposal.collateralId,\r\n                checkCollateralStateFingerprint: proposal.checkCollateralStateFingerprint,\r\n                collateralStateFingerprint: proposal.collateralStateFingerprint,\r\n                creditAmount: proposalValues.creditAmount,\r\n                availableCreditLimit: proposal.availableCreditLimit,\r\n                utilizedCreditId: proposal.utilizedCreditId,\r\n                expiration: proposal.expiration,\r\n                allowedAcceptor: proposal.allowedAcceptor,\r\n                proposer: proposal.proposer,\r\n                isOffer: proposal.isOffer,\r\n                refinancingLoanId: proposal.refinancingLoanId,\r\n                nonceSpace: proposal.nonceSpace,\r\n                nonce: proposal.nonce,\r\n                loanContract: proposal.loanContract\r\n            })\r\n        );\r\n\r\n        // Create loan terms object\r\n        loanTerms = PWNSimpleLoan.Terms({\r\n            lender: proposal.isOffer ? proposal.proposer : acceptor,\r\n            borrower: proposal.isOffer ? acceptor : proposal.proposer,\r\n            duration: _getLoanDuration(proposal.durationOrDate),\r\n            collateral: MultiToken.Asset({\r\n                category: proposal.collateralCategory,\r\n                assetAddress: proposal.collateralAddress,\r\n                id: proposal.collateralId,\r\n                amount: collateralAmount\r\n            }),\r\n            credit: MultiToken.ERC20({\r\n                assetAddress: proposal.creditAddress,\r\n                amount: proposalValues.creditAmount\r\n            }),\r\n            fixedInterestAmount: proposal.fixedInterestAmount,\r\n            accruingInterestAPR: proposal.accruingInterestAPR,\r\n            lenderSpecHash: proposal.isOffer ? proposal.proposerSpecHash : bytes32(0),\r\n            borrowerSpecHash: proposal.isOffer ? bytes32(0) : proposal.proposerSpecHash\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Encode proposal data for EIP-712.\r\n     * @param proposal Proposal struct to be encoded.\r\n     * @return encodedProposal Encoded proposal data.\r\n     */\r\n    function _erc712EncodeProposal(Proposal memory proposal) internal pure returns (bytes memory encodedProposal) {\r\n        encodedProposal = abi.encode(\r\n            proposal.collateralCategory,\r\n            proposal.collateralAddress,\r\n            proposal.collateralId,\r\n            proposal.checkCollateralStateFingerprint,\r\n            proposal.collateralStateFingerprint,\r\n            proposal.creditAddress,\r\n            keccak256(abi.encodePacked(proposal.feedIntermediaryDenominations)),\r\n            keccak256(abi.encodePacked(proposal.feedInvertFlags)),\r\n            proposal.loanToValue,\r\n            proposal.minCreditAmount,\r\n            proposal.availableCreditLimit,\r\n            proposal.utilizedCreditId\r\n        );\r\n\r\n        encodedProposal = abi.encodePacked(\r\n            encodedProposal,\r\n            abi.encode(\r\n                proposal.fixedInterestAmount,\r\n                proposal.accruingInterestAPR,\r\n                proposal.durationOrDate,\r\n                proposal.expiration,\r\n                proposal.allowedAcceptor,\r\n                proposal.proposer,\r\n                proposal.proposerSpecHash,\r\n                proposal.isOffer,\r\n                proposal.refinancingLoanId,\r\n                proposal.nonceSpace,\r\n                proposal.nonce,\r\n                proposal.loanContract\r\n            )\r\n        );\r\n    }\r\n\r\n}\r\n"
        },
        "src/loan/terms/simple/proposal/PWNSimpleLoanProposal.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport { MerkleProof } from \"openzeppelin/utils/cryptography/MerkleProof.sol\";\r\nimport { ERC165Checker } from \"openzeppelin/utils/introspection/ERC165Checker.sol\";\r\n\r\nimport { PWNConfig, IStateFingerpringComputer } from \"pwn/config/PWNConfig.sol\";\r\nimport { PWNHub } from \"pwn/hub/PWNHub.sol\";\r\nimport { PWNHubTags } from \"pwn/hub/PWNHubTags.sol\";\r\nimport { IERC5646 } from \"pwn/interfaces/IERC5646.sol\";\r\nimport { PWNSignatureChecker } from \"pwn/loan/lib/PWNSignatureChecker.sol\";\r\nimport { PWNSimpleLoan } from \"pwn/loan/terms/simple/loan/PWNSimpleLoan.sol\";\r\nimport { PWNUtilizedCredit } from \"pwn/utilized-credit/PWNUtilizedCredit.sol\";\r\nimport { PWNRevokedNonce } from \"pwn/nonce/PWNRevokedNonce.sol\";\r\nimport { Expired, AddressMissingHubTag } from \"pwn/PWNErrors.sol\";\r\n\r\n/**\r\n * @title PWN Simple Loan Proposal Base Contract\r\n * @notice Base contract of loan proposals that builds a simple loan terms.\r\n */\r\nabstract contract PWNSimpleLoanProposal {\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # VARIABLES \u0026 CONSTANTS DEFINITIONS                     *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    bytes32 public immutable DOMAIN_SEPARATOR;\r\n    bytes32 public immutable MULTIPROPOSAL_DOMAIN_SEPARATOR;\r\n\r\n    PWNHub public immutable hub;\r\n    PWNRevokedNonce public immutable revokedNonce;\r\n    PWNConfig public immutable config;\r\n    PWNUtilizedCredit public immutable utilizedCredit;\r\n\r\n    bytes32 public constant MULTIPROPOSAL_TYPEHASH = keccak256(\"Multiproposal(bytes32 multiproposalMerkleRoot)\");\r\n\r\n    struct Multiproposal {\r\n        bytes32 multiproposalMerkleRoot;\r\n    }\r\n\r\n    struct ProposalBase {\r\n        address collateralAddress;\r\n        uint256 collateralId;\r\n        bool checkCollateralStateFingerprint;\r\n        bytes32 collateralStateFingerprint;\r\n        uint256 creditAmount;\r\n        uint256 availableCreditLimit;\r\n        bytes32 utilizedCreditId;\r\n        uint40 expiration;\r\n        address allowedAcceptor;\r\n        address proposer;\r\n        bool isOffer;\r\n        uint256 refinancingLoanId;\r\n        uint256 nonceSpace;\r\n        uint256 nonce;\r\n        address loanContract;\r\n    }\r\n\r\n    /**\r\n     * @dev Mapping of proposals made via on-chain transactions.\r\n     *      Could be used by contract wallets instead of EIP-1271.\r\n     *      (proposal hash =\u003e is made)\r\n     */\r\n    mapping (bytes32 =\u003e bool) public proposalsMade;\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # ERRORS DEFINITIONS                                    *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Thrown when a caller is missing a required hub tag.\r\n     */\r\n    error CallerNotLoanContract(address caller, address loanContract);\r\n\r\n    /**\r\n     * @notice Thrown when a state fingerprint computer is not registered.\r\n     */\r\n    error MissingStateFingerprintComputer();\r\n\r\n    /**\r\n     * @notice Thrown when a proposed collateral state fingerprint doesn\u0027t match the current state.\r\n     */\r\n    error InvalidCollateralStateFingerprint(bytes32 current, bytes32 proposed);\r\n\r\n    /**\r\n     * @notice Thrown when a caller is not a stated proposer.\r\n     */\r\n    error CallerIsNotStatedProposer(address addr);\r\n\r\n    /**\r\n     * @notice Thrown when proposal acceptor and proposer are the same.\r\n     */\r\n    error AcceptorIsProposer(address addr);\r\n\r\n    /**\r\n     * @notice Thrown when provided refinance loan id cannot be used.\r\n     */\r\n    error InvalidRefinancingLoanId(uint256 refinancingLoanId);\r\n\r\n    /**\r\n     * @notice Thrown when caller is not allowed to accept a proposal.\r\n     */\r\n    error CallerNotAllowedAcceptor(address current, address allowed);\r\n\r\n    /**\r\n     * @notice Thrown when a default date is in the past.\r\n     */\r\n    error DefaultDateInPast(uint32 defaultDate, uint32 current);\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # CONSTRUCTOR                                           *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    constructor(\r\n        address _hub,\r\n        address _revokedNonce,\r\n        address _config,\r\n        address _utilizedCredit,\r\n        string memory name,\r\n        string memory version\r\n    ) {\r\n        hub = PWNHub(_hub);\r\n        revokedNonce = PWNRevokedNonce(_revokedNonce);\r\n        config = PWNConfig(_config);\r\n        utilizedCredit = PWNUtilizedCredit(_utilizedCredit);\r\n\r\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n            keccak256(abi.encodePacked(name)),\r\n            keccak256(abi.encodePacked(version)),\r\n            block.chainid,\r\n            address(this)\r\n        ));\r\n\r\n        MULTIPROPOSAL_DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n            keccak256(\"EIP712Domain(string name)\"),\r\n            keccak256(\"PWNMultiproposal\")\r\n        ));\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # EXTERNALS                                             *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Get a multiproposal hash according to EIP-712.\r\n     * @param multiproposal Multiproposal struct.\r\n     * @return Multiproposal hash.\r\n     */\r\n    function getMultiproposalHash(Multiproposal memory multiproposal) public view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\r\n            hex\"1901\", MULTIPROPOSAL_DOMAIN_SEPARATOR, keccak256(abi.encodePacked(\r\n                MULTIPROPOSAL_TYPEHASH, abi.encode(multiproposal)\r\n            ))\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * @notice Helper function for revoking a proposal nonce on behalf of a caller.\r\n     * @param nonceSpace Nonce space of a proposal nonce to be revoked.\r\n     * @param nonce Proposal nonce to be revoked.\r\n     */\r\n    function revokeNonce(uint256 nonceSpace, uint256 nonce) external {\r\n        revokedNonce.revokeNonce(msg.sender, nonceSpace, nonce);\r\n    }\r\n\r\n    /**\r\n     * @notice Accept a proposal and create new loan terms.\r\n     * @dev Function can be called only by a loan contract with appropriate PWN Hub tag.\r\n     * @param acceptor Address of a proposal acceptor.\r\n     * @param refinancingLoanId Id of a loan to be refinanced. 0 if creating a new loan.\r\n     * @param proposalData Encoded proposal data with signature.\r\n     * @param proposalInclusionProof Multiproposal inclusion proof. Empty if single proposal.\r\n     * @return proposalHash Proposal hash.\r\n     * @return loanTerms Loan terms.\r\n     */\r\n    function acceptProposal(\r\n        address acceptor,\r\n        uint256 refinancingLoanId,\r\n        bytes calldata proposalData,\r\n        bytes32[] calldata proposalInclusionProof,\r\n        bytes calldata signature\r\n    ) virtual external returns (bytes32 proposalHash, PWNSimpleLoan.Terms memory loanTerms);\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # INTERNALS                                             *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Get a proposal hash according to EIP-712.\r\n     * @param encodedProposal Encoded proposal struct.\r\n     * @return Struct hash.\r\n     */\r\n    function _getProposalHash(\r\n        bytes32 proposalTypehash,\r\n        bytes memory encodedProposal\r\n    ) internal view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\r\n            hex\"1901\", DOMAIN_SEPARATOR, keccak256(abi.encodePacked(\r\n                proposalTypehash, encodedProposal\r\n            ))\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * @notice Make an on-chain proposal.\r\n     * @dev Function will mark a proposal hash as proposed.\r\n     * @param proposalHash Proposal hash.\r\n     * @param proposer Address of a proposal proposer.\r\n     */\r\n    function _makeProposal(bytes32 proposalHash, address proposer) internal {\r\n        if (msg.sender != proposer) {\r\n            revert CallerIsNotStatedProposer({ addr: proposer });\r\n        }\r\n\r\n        proposalsMade[proposalHash] = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Get loan duration from a duration or date value.\r\n     * @param durationOrDate Duration or date value.\r\n     * @return Loan duration.\r\n     */\r\n    function _getLoanDuration(uint32 durationOrDate) internal view returns (uint32) {\r\n        if (durationOrDate \u003c= 1e9) {\r\n            // Value is duration\r\n            return durationOrDate;\r\n        } else if (durationOrDate \u003e block.timestamp) {\r\n            // Value is date\r\n            return uint32(uint256(durationOrDate) - block.timestamp);\r\n        } else {\r\n            revert DefaultDateInPast({ defaultDate: durationOrDate, current: uint32(block.timestamp) });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Try to accept proposal base.\r\n     * @param acceptor Address of a proposal acceptor.\r\n     * @param refinancingLoanId Refinancing loan ID.\r\n     * @param proposalHash Proposal hash.\r\n     * @param proposalInclusionProof Multiproposal inclusion proof. Empty if single proposal.\r\n     * @param signature Signature of a proposal.\r\n     * @param proposal Proposal base struct.\r\n     */\r\n    function _acceptProposal(\r\n        address acceptor,\r\n        uint256 refinancingLoanId,\r\n        bytes32 proposalHash,\r\n        bytes32[] calldata proposalInclusionProof,\r\n        bytes calldata signature,\r\n        ProposalBase memory proposal\r\n    ) internal {\r\n        // Check loan contract\r\n        if (msg.sender != proposal.loanContract) {\r\n            revert CallerNotLoanContract({ caller: msg.sender, loanContract: proposal.loanContract });\r\n        }\r\n        if (!hub.hasTag(proposal.loanContract, PWNHubTags.ACTIVE_LOAN)) {\r\n            revert AddressMissingHubTag({ addr: proposal.loanContract, tag: PWNHubTags.ACTIVE_LOAN });\r\n        }\r\n\r\n        // Check proposal signature or that it was made on-chain\r\n        if (proposalInclusionProof.length == 0) {\r\n            // Single proposal signature\r\n            if (!proposalsMade[proposalHash]) {\r\n                if (!PWNSignatureChecker.isValidSignatureNow(proposal.proposer, proposalHash, signature)) {\r\n                    revert PWNSignatureChecker.InvalidSignature({ signer: proposal.proposer, digest: proposalHash });\r\n                }\r\n            }\r\n        } else {\r\n            // Multiproposal signature\r\n            bytes32 multiproposalHash = getMultiproposalHash(\r\n                Multiproposal({\r\n                    multiproposalMerkleRoot: MerkleProof.processProofCalldata({\r\n                        proof: proposalInclusionProof,\r\n                        leaf: proposalHash\r\n                    })\r\n                })\r\n            );\r\n            if (!PWNSignatureChecker.isValidSignatureNow(proposal.proposer, multiproposalHash, signature)) {\r\n                revert PWNSignatureChecker.InvalidSignature({ signer: proposal.proposer, digest: multiproposalHash });\r\n            }\r\n        }\r\n\r\n        // Check proposer is not acceptor\r\n        if (proposal.proposer == acceptor) {\r\n            revert AcceptorIsProposer({ addr: acceptor});\r\n        }\r\n\r\n        // Check refinancing proposal\r\n        if (refinancingLoanId == 0) {\r\n            if (proposal.refinancingLoanId != 0) {\r\n                revert InvalidRefinancingLoanId({ refinancingLoanId: proposal.refinancingLoanId });\r\n            }\r\n        } else {\r\n            if (refinancingLoanId != proposal.refinancingLoanId) {\r\n                if (proposal.refinancingLoanId != 0 || !proposal.isOffer) {\r\n                    revert InvalidRefinancingLoanId({ refinancingLoanId: proposal.refinancingLoanId });\r\n                }\r\n            }\r\n        }\r\n\r\n        // Check proposal is not expired\r\n        if (block.timestamp \u003e= proposal.expiration) {\r\n            revert Expired({ current: block.timestamp, expiration: proposal.expiration });\r\n        }\r\n\r\n        // Check proposal is not revoked\r\n        if (!revokedNonce.isNonceUsable(proposal.proposer, proposal.nonceSpace, proposal.nonce)) {\r\n            revert PWNRevokedNonce.NonceNotUsable({\r\n                addr: proposal.proposer,\r\n                nonceSpace: proposal.nonceSpace,\r\n                nonce: proposal.nonce\r\n            });\r\n        }\r\n\r\n        // Check propsal is accepted by an allowed address\r\n        if (proposal.allowedAcceptor != address(0) \u0026\u0026 acceptor != proposal.allowedAcceptor) {\r\n            revert CallerNotAllowedAcceptor({ current: acceptor, allowed: proposal.allowedAcceptor });\r\n        }\r\n\r\n        if (proposal.availableCreditLimit == 0) {\r\n            // Revoke nonce if credit limit is 0, proposal can be accepted only once\r\n            revokedNonce.revokeNonce(proposal.proposer, proposal.nonceSpace, proposal.nonce);\r\n        } else {\r\n            // Update utilized credit\r\n            // Note: This will revert if utilized credit would exceed the available credit limit\r\n            utilizedCredit.utilizeCredit(\r\n                proposal.proposer, proposal.utilizedCreditId, proposal.creditAmount, proposal.availableCreditLimit\r\n            );\r\n        }\r\n\r\n        // Check collateral state fingerprint if needed\r\n        if (proposal.checkCollateralStateFingerprint) {\r\n            bytes32 currentFingerprint;\r\n            IStateFingerpringComputer computer = config.getStateFingerprintComputer(proposal.collateralAddress);\r\n            if (address(computer) != address(0)) {\r\n                // Asset has registered computer\r\n                currentFingerprint = computer.computeStateFingerprint({\r\n                    token: proposal.collateralAddress, tokenId: proposal.collateralId\r\n                });\r\n            } else if (ERC165Checker.supportsInterface(proposal.collateralAddress, type(IERC5646).interfaceId)) {\r\n                // Asset implements ERC5646\r\n                currentFingerprint = IERC5646(proposal.collateralAddress).getStateFingerprint(proposal.collateralId);\r\n            } else {\r\n                // Asset is not implementing ERC5646 and no computer is registered\r\n                revert MissingStateFingerprintComputer();\r\n            }\r\n\r\n            if (proposal.collateralStateFingerprint != currentFingerprint) {\r\n                // Fingerprint mismatch\r\n                revert InvalidCollateralStateFingerprint({\r\n                    current: currentFingerprint,\r\n                    proposed: proposal.collateralStateFingerprint\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n"
        },
        "src/loan/token/PWNLOAN.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport { ERC721 } from \"openzeppelin/token/ERC721/ERC721.sol\";\r\n\r\nimport { PWNHub } from \"pwn/hub/PWNHub.sol\";\r\nimport { PWNHubTags } from \"pwn/hub/PWNHubTags.sol\";\r\nimport { IERC5646 } from \"pwn/interfaces/IERC5646.sol\";\r\nimport { IPWNLoanMetadataProvider } from \"pwn/interfaces/IPWNLoanMetadataProvider.sol\";\r\n\r\n\r\n/**\r\n * @title PWN LOAN token\r\n * @notice A LOAN token representing a loan in PWN protocol.\r\n * @dev Token doesn\u0027t hold any loan logic, just an address of a loan contract that minted the LOAN token.\r\n *      PWN LOAN token is shared between all loan contracts.\r\n */\r\ncontract PWNLOAN is ERC721, IERC5646 {\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # VARIABLES \u0026 CONSTANTS DEFINITIONS                     *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    PWNHub public immutable hub;\r\n\r\n    /**\r\n     * @dev Last used LOAN id. First LOAN id is 1. This value is incremental.\r\n     */\r\n    uint256 public lastLoanId;\r\n\r\n    /**\r\n     * @dev Mapping of a LOAN id to a loan contract that minted the LOAN token.\r\n     */\r\n    mapping (uint256 =\u003e address) public loanContract;\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # EVENTS DEFINITIONS                                    *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Emitted when a new LOAN token is minted.\r\n     */\r\n    event LOANMinted(uint256 indexed loanId, address indexed loanContract, address indexed owner);\r\n\r\n    /**\r\n     * @notice Emitted when a LOAN token is burned.\r\n     */\r\n    event LOANBurned(uint256 indexed loanId);\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # ERRORS DEFINITIONS                                    *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Thrown when `PWNLOAN.burn` caller is not a loan contract that minted the LOAN token.\r\n     */\r\n    error InvalidLoanContractCaller();\r\n\r\n    /**\r\n     * @notice Thrown when caller is missing a PWN Hub tag.\r\n     */\r\n    error CallerMissingHubTag(bytes32 tag);\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # MODIFIERS                                             *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    modifier onlyActiveLoan() {\r\n        if (!hub.hasTag(msg.sender, PWNHubTags.ACTIVE_LOAN))\r\n            revert CallerMissingHubTag({ tag: PWNHubTags.ACTIVE_LOAN });\r\n        _;\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # CONSTRUCTOR                                           *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    constructor(address _hub) ERC721(\"PWN LOAN\", \"LOAN\") {\r\n        hub = PWNHub(_hub);\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # TOKEN LIFECYCLE                                       *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Mint a new LOAN token.\r\n     * @dev Only an address with associated `ACTIVE_LOAN` tag in PWN Hub can call this function.\r\n     * @param owner Address of a LOAN token receiver.\r\n     * @return loanId Id of a newly minted LOAN token.\r\n     */\r\n    function mint(address owner) external onlyActiveLoan returns (uint256 loanId) {\r\n        loanId = ++lastLoanId;\r\n        loanContract[loanId] = msg.sender;\r\n        _mint(owner, loanId);\r\n        emit LOANMinted(loanId, msg.sender, owner);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn a LOAN token.\r\n     * @dev Any address that is associated with given loan id can call this function.\r\n     *      It is enabled to let deprecated loan contracts repay and claim existing loans.\r\n     * @param loanId Id of a LOAN token to be burned.\r\n     */\r\n    function burn(uint256 loanId) external {\r\n        if (loanContract[loanId] != msg.sender)\r\n            revert InvalidLoanContractCaller();\r\n\r\n        delete loanContract[loanId];\r\n        _burn(loanId);\r\n        emit LOANBurned(loanId);\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # METADATA                                              *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Return a LOAN token metadata uri base on a loan contract that minted the token.\r\n     * @param tokenId Id of a LOAN token.\r\n     * @return Metadata uri for given token id (loan id).\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        _requireMinted(tokenId);\r\n\r\n        return IPWNLoanMetadataProvider(loanContract[tokenId]).loanMetadataUri();\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # ERC5646                                               *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @dev See {IERC5646-getStateFingerprint}.\r\n     */\r\n    function getStateFingerprint(uint256 tokenId) external view virtual override returns (bytes32) {\r\n        address _loanContract = loanContract[tokenId];\r\n\r\n        if (_loanContract == address(0))\r\n            return bytes32(0);\r\n\r\n        return IERC5646(_loanContract).getStateFingerprint(tokenId);\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # ERC165                                                *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return super.supportsInterface(interfaceId) ||\r\n            interfaceId == type(IERC5646).interfaceId;\r\n    }\r\n\r\n}\r\n"
        },
        "src/loan/utils/safeFetchDecimals.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\n\r\nfunction safeFetchDecimals(address asset) view returns (uint256) {\r\n    (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSignature(\"decimals()\"));\r\n    if (!success || returndata.length == 0) {\r\n        return 0;\r\n    }\r\n    return abi.decode(returndata, (uint256));\r\n}\r\n"
        },
        "src/loan/vault/PWNVault.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport { MultiToken } from \"MultiToken/MultiToken.sol\";\r\n\r\nimport { IERC721Receiver } from \"openzeppelin/token/ERC721/IERC721Receiver.sol\";\r\nimport { IERC1155Receiver, IERC165 } from \"openzeppelin/token/ERC1155/IERC1155Receiver.sol\";\r\n\r\nimport { IPoolAdapter } from \"pwn/interfaces/IPoolAdapter.sol\";\r\n\r\n\r\n/**\r\n * @title PWN Vault\r\n * @notice Base contract for transferring and managing collateral and loan assets in PWN protocol.\r\n * @dev Loan contracts inherits PWN Vault to act as a Vault for its loan type.\r\n */\r\nabstract contract PWNVault is IERC721Receiver, IERC1155Receiver {\r\n    using MultiToken for MultiToken.Asset;\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # EVENTS DEFINITIONS                                    *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Emitted when asset transfer happens from an `origin` address to a vault.\r\n     */\r\n    event VaultPull(MultiToken.Asset asset, address indexed origin);\r\n\r\n    /**\r\n     * @notice Emitted when asset transfer happens from a vault to a `beneficiary` address.\r\n     */\r\n    event VaultPush(MultiToken.Asset asset, address indexed beneficiary);\r\n\r\n    /**\r\n     * @notice Emitted when asset transfer happens from an `origin` address to a `beneficiary` address.\r\n     */\r\n    event VaultPushFrom(MultiToken.Asset asset, address indexed origin, address indexed beneficiary);\r\n\r\n    /**\r\n     * @notice Emitted when asset is withdrawn from a pool to an `owner` address.\r\n     */\r\n    event PoolWithdraw(MultiToken.Asset asset, address indexed poolAdapter, address indexed pool, address indexed owner);\r\n\r\n    /**\r\n     * @notice Emitted when asset is supplied to a pool from a vault.\r\n     */\r\n    event PoolSupply(MultiToken.Asset asset, address indexed poolAdapter, address indexed pool, address indexed owner);\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # ERRORS DEFINITIONS                                    *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Thrown when the Vault receives an asset that is not transferred by the Vault itself.\r\n     */\r\n    error UnsupportedTransferFunction();\r\n\r\n    /**\r\n     * @notice Thrown when an asset transfer is incomplete.\r\n     */\r\n    error IncompleteTransfer();\r\n\r\n    /**\r\n     * @notice Thrown when an asset transfer source and destination address are the same.\r\n     */\r\n    error VaultTransferSameSourceAndDestination(address addr);\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # TRANSFER FUNCTIONS                                    *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Function pulling an asset into a vault.\r\n     * @dev The function assumes a prior token approval to a vault address.\r\n     * @param asset An asset construct - for a definition see { MultiToken dependency lib }.\r\n     * @param origin Borrower address that is transferring collateral to Vault or repaying a loan.\r\n     */\r\n    function _pull(MultiToken.Asset memory asset, address origin) internal {\r\n        uint256 originalBalance = asset.balanceOf(address(this));\r\n\r\n        asset.transferAssetFrom(origin, address(this));\r\n        _checkTransfer({\r\n            asset: asset,\r\n            originalBalance: originalBalance,\r\n            checkedAddress: address(this),\r\n            counterPartyAddress: origin,\r\n            checkIncreasingBalance: true\r\n        });\r\n\r\n        emit VaultPull(asset, origin);\r\n    }\r\n\r\n    /**\r\n     * @notice Function pushing an asset from a vault to a recipient.\r\n     * @dev This is used for claiming a paid back loan or a defaulted collateral, or returning collateral to a borrower.\r\n     * @param asset An asset construct - for a definition see { MultiToken dependency lib }.\r\n     * @param beneficiary An address of a recipient of an asset.\r\n     */\r\n    function _push(MultiToken.Asset memory asset, address beneficiary) internal {\r\n        uint256 originalBalance = asset.balanceOf(beneficiary);\r\n\r\n        asset.safeTransferAssetFrom(address(this), beneficiary);\r\n        _checkTransfer({\r\n            asset: asset,\r\n            originalBalance: originalBalance,\r\n            checkedAddress: beneficiary,\r\n            counterPartyAddress: address(this),\r\n            checkIncreasingBalance: true\r\n        });\r\n\r\n        emit VaultPush(asset, beneficiary);\r\n    }\r\n\r\n    /**\r\n     * @notice Function pushing an asset from an origin address to a beneficiary address.\r\n     * @dev The function assumes a prior token approval to a vault address.\r\n     * @param asset An asset construct - for a definition see { MultiToken dependency lib }.\r\n     * @param origin An address of a lender who is providing a loan asset.\r\n     * @param beneficiary An address of the recipient of an asset.\r\n     */\r\n    function _pushFrom(MultiToken.Asset memory asset, address origin, address beneficiary) internal {\r\n        uint256 originalBalance = asset.balanceOf(beneficiary);\r\n\r\n        asset.safeTransferAssetFrom(origin, beneficiary);\r\n        _checkTransfer({\r\n            asset: asset,\r\n            originalBalance: originalBalance,\r\n            checkedAddress: beneficiary,\r\n            counterPartyAddress: origin,\r\n            checkIncreasingBalance: true\r\n        });\r\n\r\n        emit VaultPushFrom(asset, origin, beneficiary);\r\n    }\r\n\r\n    /**\r\n     * @notice Function withdrawing an asset from a Compound pool to the owner.\r\n     * @dev The function assumes a prior check for a valid pool address.\r\n     * @param asset An asset construct - for a definition see { MultiToken dependency lib }.\r\n     * @param poolAdapter An address of a pool adapter.\r\n     * @param pool An address of a pool.\r\n     * @param owner An address on which behalf the assets are withdrawn.\r\n     */\r\n    function _withdrawFromPool(MultiToken.Asset memory asset, IPoolAdapter poolAdapter, address pool, address owner) internal {\r\n        uint256 originalBalance = asset.balanceOf(owner);\r\n\r\n        poolAdapter.withdraw(pool, owner, asset.assetAddress, asset.amount);\r\n        _checkTransfer({\r\n            asset: asset,\r\n            originalBalance: originalBalance,\r\n            checkedAddress: owner,\r\n            counterPartyAddress: pool,\r\n            checkIncreasingBalance: true\r\n        });\r\n\r\n        emit PoolWithdraw(asset, address(poolAdapter), pool, owner);\r\n    }\r\n\r\n    /**\r\n     * @notice Function supplying an asset to a pool from a vault via a pool adapter.\r\n     * @dev The function assumes a prior check for a valid pool address.\r\n     *      Assuming pool will revert supply transaction if it fails.\r\n     * @param asset An asset construct - for a definition see { MultiToken dependency lib }.\r\n     * @param poolAdapter An address of a pool adapter.\r\n     * @param pool An address of a pool.\r\n     * @param owner An address on which behalf the asset is supplied.\r\n     */\r\n    function _supplyToPool(MultiToken.Asset memory asset, IPoolAdapter poolAdapter, address pool, address owner) internal {\r\n        uint256 originalBalance = asset.balanceOf(address(this));\r\n\r\n        asset.transferAssetFrom(address(this), address(poolAdapter));\r\n        poolAdapter.supply(pool, owner, asset.assetAddress, asset.amount);\r\n        _checkTransfer({\r\n            asset: asset,\r\n            originalBalance: originalBalance,\r\n            checkedAddress: address(this),\r\n            counterPartyAddress: pool,\r\n            checkIncreasingBalance: false\r\n        });\r\n\r\n        // Note: Assuming pool will revert supply transaction if it fails.\r\n\r\n        emit PoolSupply(asset, address(poolAdapter), pool, owner);\r\n    }\r\n\r\n    function _checkTransfer(\r\n        MultiToken.Asset memory asset,\r\n        uint256 originalBalance,\r\n        address checkedAddress,\r\n        address counterPartyAddress,\r\n        bool checkIncreasingBalance\r\n    ) private view {\r\n        if (checkedAddress == counterPartyAddress) {\r\n            revert VaultTransferSameSourceAndDestination({ addr: checkedAddress });\r\n        }\r\n\r\n        uint256 expectedBalance = checkIncreasingBalance\r\n            ? originalBalance + asset.getTransferAmount()\r\n            : originalBalance - asset.getTransferAmount();\r\n\r\n        if (expectedBalance != asset.balanceOf(checkedAddress)) {\r\n            revert IncompleteTransfer();\r\n        }\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # ERC721/1155 RECEIVED HOOKS                            *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * @return `IERC721Receiver.onERC721Received.selector` if transfer is allowed\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address /*from*/,\r\n        uint256 /*tokenId*/,\r\n        bytes calldata /*data*/\r\n    ) override external view returns (bytes4) {\r\n        if (operator != address(this))\r\n            revert UnsupportedTransferFunction();\r\n\r\n        return IERC721Receiver.onERC721Received.selector;\r\n    }\r\n\r\n    /**\r\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\r\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\r\n     * To accept the transfer, this must return\r\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     * (i.e. 0xf23a6e61, or its own function selector).\r\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address /*from*/,\r\n        uint256 /*id*/,\r\n        uint256 /*value*/,\r\n        bytes calldata /*data*/\r\n    ) override external view returns (bytes4) {\r\n        if (operator != address(this))\r\n            revert UnsupportedTransferFunction();\r\n\r\n        return IERC1155Receiver.onERC1155Received.selector;\r\n    }\r\n\r\n    /**\r\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\r\n     * been updated. To accept the transfer(s), this must return\r\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     * (i.e. 0xbc197c81, or its own function selector).\r\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address /*operator*/,\r\n        address /*from*/,\r\n        uint256[] calldata /*ids*/,\r\n        uint256[] calldata /*values*/,\r\n        bytes calldata /*data*/\r\n    ) override external pure returns (bytes4) {\r\n        revert UnsupportedTransferFunction();\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # SUPPORTED INTERFACES                                  *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external pure virtual override returns (bool) {\r\n        return\r\n            interfaceId == type(IERC165).interfaceId ||\r\n            interfaceId == type(IERC721Receiver).interfaceId ||\r\n            interfaceId == type(IERC1155Receiver).interfaceId;\r\n    }\r\n\r\n}\r\n"
        },
        "src/nonce/PWNRevokedNonce.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport { PWNHub } from \"pwn/hub/PWNHub.sol\";\r\nimport { PWNHubTags } from \"pwn/hub/PWNHubTags.sol\";\r\nimport { AddressMissingHubTag } from \"pwn/PWNErrors.sol\";\r\n\r\n\r\n/**\r\n * @title PWN Revoked Nonce\r\n * @notice Contract holding revoked nonces.\r\n */\r\ncontract PWNRevokedNonce {\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # VARIABLES \u0026 CONSTANTS DEFINITIONS                     *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Access tag that needs to be assigned to a caller in PWN Hub\r\n     *         to call functions that revoke nonces on behalf of an owner.\r\n     */\r\n    bytes32 public immutable accessTag;\r\n\r\n    /**\r\n     * @notice PWN Hub contract.\r\n     * @dev Addresses revoking nonces on behalf of an owner need to have an access tag in PWN Hub.\r\n     */\r\n    PWNHub public immutable hub;\r\n\r\n    /**\r\n     * @notice Mapping of revoked nonces by an address. Every address has its own nonce space.\r\n     *         (owner =\u003e nonce space =\u003e nonce =\u003e is revoked)\r\n     */\r\n    mapping (address =\u003e mapping (uint256 =\u003e mapping (uint256 =\u003e bool))) private _revokedNonce;\r\n\r\n    /**\r\n     * @notice Mapping of current nonce space for an address.\r\n     */\r\n    mapping (address =\u003e uint256) private _nonceSpace;\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # EVENTS DEFINITIONS                                    *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Emitted when a nonce is revoked.\r\n     */\r\n    event NonceRevoked(address indexed owner, uint256 indexed nonceSpace, uint256 indexed nonce);\r\n\r\n    /**\r\n     * @notice Emitted when a nonce is revoked.\r\n     */\r\n    event NonceSpaceRevoked(address indexed owner, uint256 indexed nonceSpace);\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # ERRORS DEFINITIONS                                    *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Thrown when trying to revoke a nonce that is already revoked.\r\n     */\r\n    error NonceAlreadyRevoked(address addr, uint256 nonceSpace, uint256 nonce);\r\n\r\n    /**\r\n     * @notice Thrown when nonce is currently not usable.\r\n     * @dev Maybe nonce is revoked or not in the current nonce space.\r\n     */\r\n    error NonceNotUsable(address addr, uint256 nonceSpace, uint256 nonce);\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # MODIFIERS                                             *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    modifier onlyWithHubTag() {\r\n        if (!hub.hasTag(msg.sender, accessTag))\r\n            revert AddressMissingHubTag({ addr: msg.sender, tag: accessTag });\r\n        _;\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # CONSTRUCTOR                                           *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    constructor(address _hub, bytes32 _accessTag) {\r\n        accessTag = _accessTag;\r\n        hub = PWNHub(_hub);\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # NONCE                                                 *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Revoke callers nonce in the current nonce space.\r\n     * @param nonce Nonce to be revoked.\r\n     */\r\n    function revokeNonce(uint256 nonce) external {\r\n        _revokeNonce(msg.sender, _nonceSpace[msg.sender], nonce);\r\n    }\r\n\r\n    /**\r\n     * @notice Revoke multiple caller nonces in the current nonce space.\r\n     * @param nonces List of nonces to be revoked.\r\n     */\r\n    function revokeNonces(uint256[] calldata nonces) external {\r\n        uint256 nonceSpace = _nonceSpace[msg.sender];\r\n        for (uint256 i; i \u003c nonces.length; ++i) {\r\n            _revokeNonce(msg.sender, nonceSpace, nonces[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Revoke caller nonce in a nonce space.\r\n     * @param nonceSpace Nonce space where a nonce will be revoked.\r\n     * @param nonce Nonce to be revoked.\r\n     */\r\n    function revokeNonce(uint256 nonceSpace, uint256 nonce) external {\r\n        _revokeNonce(msg.sender, nonceSpace, nonce);\r\n    }\r\n\r\n    /**\r\n     * @notice Revoke a nonce in the current nonce space on behalf of an owner.\r\n     * @dev Only an address with associated access tag in PWN Hub can call this function.\r\n     * @param owner Owner address of a revoking nonce.\r\n     * @param nonce Nonce to be revoked.\r\n     */\r\n    function revokeNonce(address owner, uint256 nonce) external onlyWithHubTag {\r\n        _revokeNonce(owner, _nonceSpace[owner], nonce);\r\n    }\r\n\r\n    /**\r\n     * @notice Revoke a nonce in a nonce space on behalf of an owner.\r\n     * @dev Only an address with associated access tag in PWN Hub can call this function.\r\n     * @param owner Owner address of a revoking nonce.\r\n     * @param nonceSpace Nonce space where a nonce will be revoked.\r\n     * @param nonce Nonce to be revoked.\r\n     */\r\n    function revokeNonce(address owner, uint256 nonceSpace, uint256 nonce) external onlyWithHubTag {\r\n        _revokeNonce(owner, nonceSpace, nonce);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to revoke a nonce in a nonce space.\r\n     */\r\n    function _revokeNonce(address owner, uint256 nonceSpace, uint256 nonce) private {\r\n        if (_revokedNonce[owner][nonceSpace][nonce]) {\r\n            revert NonceAlreadyRevoked({ addr: owner, nonceSpace: nonceSpace, nonce: nonce });\r\n        }\r\n        _revokedNonce[owner][nonceSpace][nonce] = true;\r\n        emit NonceRevoked(owner, nonceSpace, nonce);\r\n    }\r\n\r\n    /**\r\n     * @notice Return true if owners nonce is revoked in the given nonce space.\r\n     * @dev Do not use this function to check if nonce is usable.\r\n     *      Use `isNonceUsable` instead, which checks nonce space as well.\r\n     * @param owner Address of a nonce owner.\r\n     * @param nonceSpace Value of a nonce space.\r\n     * @param nonce Value of a nonce.\r\n     * @return True if nonce is revoked.\r\n     */\r\n    function isNonceRevoked(address owner, uint256 nonceSpace, uint256 nonce) external view returns (bool) {\r\n        return _revokedNonce[owner][nonceSpace][nonce];\r\n    }\r\n\r\n    /**\r\n     * @notice Return true if owners nonce is usable. Nonce is usable if it is not revoked and in the current nonce space.\r\n     * @param owner Address of a nonce owner.\r\n     * @param nonceSpace Value of a nonce space.\r\n     * @param nonce Value of a nonce.\r\n     * @return True if nonce is usable.\r\n     */\r\n    function isNonceUsable(address owner, uint256 nonceSpace, uint256 nonce) external view returns (bool) {\r\n        if (_nonceSpace[owner] != nonceSpace)\r\n            return false;\r\n\r\n        return !_revokedNonce[owner][nonceSpace][nonce];\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # NONCE SPACE                                           *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Revoke all nonces in the current nonce space and increment nonce space.\r\n     * @dev Caller is used as a nonce owner.\r\n     * @return New nonce space.\r\n     */\r\n    function revokeNonceSpace() external returns (uint256) {\r\n        emit NonceSpaceRevoked(msg.sender, _nonceSpace[msg.sender]);\r\n        return ++_nonceSpace[msg.sender];\r\n    }\r\n\r\n    /**\r\n     * @notice Return current nonce space for an address.\r\n     * @param owner Address of a nonce owner.\r\n     * @return Current nonce space.\r\n     */\r\n    function currentNonceSpace(address owner) external view returns (uint256) {\r\n        return _nonceSpace[owner];\r\n    }\r\n\r\n}\r\n"
        },
        "src/utilized-credit/PWNUtilizedCredit.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.16;\r\n\r\nimport { PWNHub } from \"pwn/hub/PWNHub.sol\";\r\nimport { AddressMissingHubTag } from \"pwn/PWNErrors.sol\";\r\n\r\n\r\n/**\r\n * @title PWN Utilized Credit Contract\r\n * @notice Contract holding utilized credit.\r\n */\r\ncontract PWNUtilizedCredit {\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # VARIABLES \u0026 CONSTANTS DEFINITIONS                     *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Access tag that needs to be assigned to a caller in PWN Hub\r\n     *         to call functions that update utilized credit.\r\n     */\r\n    bytes32 public immutable accessTag;\r\n\r\n    /**\r\n     * @notice PWN Hub contract.\r\n     * @dev Addresses updating utilized credit need to have an access tag in PWN Hub.\r\n     */\r\n    PWNHub public immutable hub;\r\n\r\n    /**\r\n     * @notice Mapping of credit utilized by an id with defined available credit limit.\r\n     *         (owner =\u003e id =\u003e utilized credit)\r\n     */\r\n    mapping (address =\u003e mapping (bytes32 =\u003e uint256)) public utilizedCredit;\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # ERRORS DEFINITIONS                                    *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Thrown when an id would exceed the available credit limit.\r\n     */\r\n    error AvailableCreditLimitExceeded(address owner, bytes32 id, uint256 utilized, uint256 limit);\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # MODIFIERS                                             *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    modifier onlyWithHubTag() {\r\n        if (!hub.hasTag(msg.sender, accessTag))\r\n            revert AddressMissingHubTag({ addr: msg.sender, tag: accessTag });\r\n        _;\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # CONSTRUCTOR                                           *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    constructor(address _hub, bytes32 _accessTag) {\r\n        accessTag = _accessTag;\r\n        hub = PWNHub(_hub);\r\n    }\r\n\r\n\r\n    /*----------------------------------------------------------*|\r\n    |*  # UTILIZED CREDIT                                       *|\r\n    |*----------------------------------------------------------*/\r\n\r\n    /**\r\n     * @notice Update utilized credit for an owner with an id.\r\n     * @dev Function will revert if utilized credit would exceed the available credit limit.\r\n     * @param owner Owner of the utilized credit.\r\n     * @param id Id of the utilized credit.\r\n     * @param amount Amount to update utilized credit.\r\n     * @param limit Available credit limit.\r\n     */\r\n    function utilizeCredit(address owner, bytes32 id, uint256 amount, uint256 limit) external onlyWithHubTag {\r\n        uint256 extendedAmount = utilizedCredit[owner][id] + amount;\r\n        if (extendedAmount \u003e limit) {\r\n            revert AvailableCreditLimitExceeded({ owner: owner, id: id, utilized: extendedAmount, limit: limit });\r\n        }\r\n\r\n        utilizedCredit[owner][id] = extendedAmount;\r\n    }\r\n\r\n}\r\n"
        }
    }
}
